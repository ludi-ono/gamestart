(()=>{
    var e = {
        144: function(e) {
            e.exports = function() {
                "use strict";
                const e = "undefined" != typeof window
                  , t = e && !("onscroll"in window) || "undefined" != typeof navigator && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent)
                  , i = e && window.devicePixelRatio > 1
                  , n = {
                    elements_selector: ".lazy",
                    container: t || e ? document : null,
                    threshold: 300,
                    thresholds: null,
                    data_src: "src",
                    data_srcset: "srcset",
                    data_sizes: "sizes",
                    data_bg: "bg",
                    data_bg_hidpi: "bg-hidpi",
                    data_bg_multi: "bg-multi",
                    data_bg_multi_hidpi: "bg-multi-hidpi",
                    data_bg_set: "bg-set",
                    data_poster: "poster",
                    class_applied: "applied",
                    class_loading: "loading",
                    class_loaded: "loaded",
                    class_error: "error",
                    class_entered: "entered",
                    class_exited: "exited",
                    unobserve_completed: !0,
                    unobserve_entered: !1,
                    cancel_on_exit: !0,
                    callback_enter: null,
                    callback_exit: null,
                    callback_applied: null,
                    callback_loading: null,
                    callback_loaded: null,
                    callback_error: null,
                    callback_finish: null,
                    callback_cancel: null,
                    use_native: !1,
                    restore_on_error: !1
                }
                  , r = e=>Object.assign({}, n, e)
                  , s = function(e, t) {
                    let i;
                    const n = "LazyLoad::Initialized"
                      , r = new e(t);
                    try {
                        i = new CustomEvent(n,{
                            detail: {
                                instance: r
                            }
                        })
                    } catch (e) {
                        i = document.createEvent("CustomEvent"),
                        i.initCustomEvent(n, !1, !1, {
                            instance: r
                        })
                    }
                    window.dispatchEvent(i)
                }
                  , o = "src"
                  , a = "srcset"
                  , l = "sizes"
                  , d = "poster"
                  , c = "llOriginalAttrs"
                  , u = "data"
                  , p = "loading"
                  , f = "loaded"
                  , h = "applied"
                  , m = "error"
                  , v = "native"
                  , g = "data-"
                  , w = "ll-status"
                  , b = (e,t)=>e.getAttribute(g + t)
                  , y = e=>b(e, w)
                  , x = (e,t)=>((e,t,i)=>{
                    const n = g + t;
                    null !== i ? e.setAttribute(n, i) : e.removeAttribute(n)
                }
                )(e, w, t)
                  , E = e=>x(e, null)
                  , S = e=>null === y(e)
                  , T = e=>y(e) === v
                  , L = [p, f, h, m]
                  , C = (e,t,i,n)=>{
                    e && "function" == typeof e && (void 0 === n ? void 0 === i ? e(t) : e(t, i) : e(t, i, n))
                }
                  , A = (t,i)=>{
                    e && "" !== i && t.classList.add(i)
                }
                  , M = (t,i)=>{
                    e && "" !== i && t.classList.remove(i)
                }
                  , O = e=>e.llTempImage
                  , k = (e,t)=>{
                    if (!t)
                        return;
                    const i = t._observer;
                    i && i.unobserve(e)
                }
                  , P = (e,t)=>{
                    e && (e.loadingCount += t)
                }
                  , _ = (e,t)=>{
                    e && (e.toLoadCount = t)
                }
                  , I = e=>{
                    let t = [];
                    for (let i, n = 0; i = e.children[n]; n += 1)
                        "SOURCE" === i.tagName && t.push(i);
                    return t
                }
                  , D = (e,t)=>{
                    const i = e.parentNode;
                    i && "PICTURE" === i.tagName && I(i).forEach(t)
                }
                  , z = (e,t)=>{
                    I(e).forEach(t)
                }
                  , N = [o]
                  , V = [o, d]
                  , W = [o, a, l]
                  , j = [u]
                  , G = e=>!!e[c]
                  , B = e=>e[c]
                  , $ = e=>delete e[c]
                  , H = (e,t)=>{
                    if (G(e))
                        return;
                    const i = {};
                    t.forEach((t=>{
                        i[t] = e.getAttribute(t)
                    }
                    )),
                    e[c] = i
                }
                  , R = (e,t)=>{
                    if (!G(e))
                        return;
                    const i = B(e);
                    t.forEach((t=>{
                        ((e,t,i)=>{
                            i ? e.setAttribute(t, i) : e.removeAttribute(t)
                        }
                        )(e, t, i[t])
                    }
                    ))
                }
                  , F = (e,t,i)=>{
                    A(e, t.class_applied),
                    x(e, h),
                    i && (t.unobserve_completed && k(e, t),
                    C(t.callback_applied, e, i))
                }
                  , q = (e,t,i)=>{
                    A(e, t.class_loading),
                    x(e, p),
                    i && (P(i, 1),
                    C(t.callback_loading, e, i))
                }
                  , Y = (e,t,i)=>{
                    i && e.setAttribute(t, i)
                }
                  , X = (e,t)=>{
                    Y(e, l, b(e, t.data_sizes)),
                    Y(e, a, b(e, t.data_srcset)),
                    Y(e, o, b(e, t.data_src))
                }
                  , U = {
                    IMG: (e,t)=>{
                        D(e, (e=>{
                            H(e, W),
                            X(e, t)
                        }
                        )),
                        H(e, W),
                        X(e, t)
                    }
                    ,
                    IFRAME: (e,t)=>{
                        H(e, N),
                        Y(e, o, b(e, t.data_src))
                    }
                    ,
                    VIDEO: (e,t)=>{
                        z(e, (e=>{
                            H(e, N),
                            Y(e, o, b(e, t.data_src))
                        }
                        )),
                        H(e, V),
                        Y(e, d, b(e, t.data_poster)),
                        Y(e, o, b(e, t.data_src)),
                        e.load()
                    }
                    ,
                    OBJECT: (e,t)=>{
                        H(e, j),
                        Y(e, u, b(e, t.data_src))
                    }
                }
                  , K = ["IMG", "IFRAME", "VIDEO", "OBJECT"]
                  , J = (e,t)=>{
                    !t || (e=>e.loadingCount > 0)(t) || (e=>e.toLoadCount > 0)(t) || C(e.callback_finish, t)
                }
                  , Q = (e,t,i)=>{
                    e.addEventListener(t, i),
                    e.llEvLisnrs[t] = i
                }
                  , Z = (e,t,i)=>{
                    e.removeEventListener(t, i)
                }
                  , ee = e=>!!e.llEvLisnrs
                  , te = e=>{
                    if (!ee(e))
                        return;
                    const t = e.llEvLisnrs;
                    for (let i in t) {
                        const n = t[i];
                        Z(e, i, n)
                    }
                    delete e.llEvLisnrs
                }
                  , ie = (e,t,i)=>{
                    (e=>{
                        delete e.llTempImage
                    }
                    )(e),
                    P(i, -1),
                    (e=>{
                        e && (e.toLoadCount -= 1)
                    }
                    )(i),
                    M(e, t.class_loading),
                    t.unobserve_completed && k(e, i)
                }
                  , ne = (e,t,i)=>{
                    const n = O(e) || e;
                    ee(n) || ((e,t,i)=>{
                        ee(e) || (e.llEvLisnrs = {});
                        const n = "VIDEO" === e.tagName ? "loadeddata" : "load";
                        Q(e, n, t),
                        Q(e, "error", i)
                    }
                    )(n, (r=>{
                        ((e,t,i,n)=>{
                            const r = T(t);
                            ie(t, i, n),
                            A(t, i.class_loaded),
                            x(t, f),
                            C(i.callback_loaded, t, n),
                            r || J(i, n)
                        }
                        )(0, e, t, i),
                        te(n)
                    }
                    ), (r=>{
                        ((e,t,i,n)=>{
                            const r = T(t);
                            ie(t, i, n),
                            A(t, i.class_error),
                            x(t, m),
                            C(i.callback_error, t, n),
                            i.restore_on_error && R(t, W),
                            r || J(i, n)
                        }
                        )(0, e, t, i),
                        te(n)
                    }
                    ))
                }
                  , re = (e,t,n)=>{
                    (e=>K.indexOf(e.tagName) > -1)(e) ? ((e,t,i)=>{
                        ne(e, t, i),
                        ((e,t,i)=>{
                            const n = U[e.tagName];
                            n && (n(e, t),
                            q(e, t, i))
                        }
                        )(e, t, i)
                    }
                    )(e, t, n) : ((e,t,n)=>{
                        (e=>{
                            e.llTempImage = document.createElement("IMG")
                        }
                        )(e),
                        ne(e, t, n),
                        (e=>{
                            G(e) || (e[c] = {
                                backgroundImage: e.style.backgroundImage
                            })
                        }
                        )(e),
                        ((e,t,n)=>{
                            const r = b(e, t.data_bg)
                              , s = b(e, t.data_bg_hidpi)
                              , a = i && s ? s : r;
                            a && (e.style.backgroundImage = `url("${a}")`,
                            O(e).setAttribute(o, a),
                            q(e, t, n))
                        }
                        )(e, t, n),
                        ((e,t,n)=>{
                            const r = b(e, t.data_bg_multi)
                              , s = b(e, t.data_bg_multi_hidpi)
                              , o = i && s ? s : r;
                            o && (e.style.backgroundImage = o,
                            F(e, t, n))
                        }
                        )(e, t, n),
                        ((e,t,i)=>{
                            const n = b(e, t.data_bg_set);
                            if (!n)
                                return;
                            let r = n.split("|").map((e=>`image-set(${e})`));
                            e.style.backgroundImage = r.join(),
                            F(e, t, i)
                        }
                        )(e, t, n)
                    }
                    )(e, t, n)
                }
                  , se = e=>{
                    e.removeAttribute(o),
                    e.removeAttribute(a),
                    e.removeAttribute(l)
                }
                  , oe = e=>{
                    D(e, (e=>{
                        R(e, W)
                    }
                    )),
                    R(e, W)
                }
                  , ae = {
                    IMG: oe,
                    IFRAME: e=>{
                        R(e, N)
                    }
                    ,
                    VIDEO: e=>{
                        z(e, (e=>{
                            R(e, N)
                        }
                        )),
                        R(e, V),
                        e.load()
                    }
                    ,
                    OBJECT: e=>{
                        R(e, j)
                    }
                }
                  , le = (e,t)=>{
                    (e=>{
                        const t = ae[e.tagName];
                        t ? t(e) : (e=>{
                            if (!G(e))
                                return;
                            const t = B(e);
                            e.style.backgroundImage = t.backgroundImage
                        }
                        )(e)
                    }
                    )(e),
                    ((e,t)=>{
                        S(e) || T(e) || (M(e, t.class_entered),
                        M(e, t.class_exited),
                        M(e, t.class_applied),
                        M(e, t.class_loading),
                        M(e, t.class_loaded),
                        M(e, t.class_error))
                    }
                    )(e, t),
                    E(e),
                    $(e)
                }
                  , de = ["IMG", "IFRAME", "VIDEO"]
                  , ce = e=>e.use_native && "loading"in HTMLImageElement.prototype
                  , ue = (e,t,i)=>{
                    e.forEach((e=>(e=>e.isIntersecting || e.intersectionRatio > 0)(e) ? ((e,t,i,n)=>{
                        const r = (e=>L.indexOf(y(e)) >= 0)(e);
                        x(e, "entered"),
                        A(e, i.class_entered),
                        M(e, i.class_exited),
                        ((e,t,i)=>{
                            t.unobserve_entered && k(e, i)
                        }
                        )(e, i, n),
                        C(i.callback_enter, e, t, n),
                        r || re(e, i, n)
                    }
                    )(e.target, e, t, i) : ((e,t,i,n)=>{
                        S(e) || (A(e, i.class_exited),
                        ((e,t,i,n)=>{
                            i.cancel_on_exit && (e=>y(e) === p)(e) && "IMG" === e.tagName && (te(e),
                            (e=>{
                                D(e, (e=>{
                                    se(e)
                                }
                                )),
                                se(e)
                            }
                            )(e),
                            oe(e),
                            M(e, i.class_loading),
                            P(n, -1),
                            E(e),
                            C(i.callback_cancel, e, t, n))
                        }
                        )(e, t, i, n),
                        C(i.callback_exit, e, t, n))
                    }
                    )(e.target, e, t, i)))
                }
                  , pe = e=>Array.prototype.slice.call(e)
                  , fe = e=>e.container.querySelectorAll(e.elements_selector)
                  , he = e=>(e=>y(e) === m)(e)
                  , me = (e,t)=>(e=>pe(e).filter(S))(e || fe(t))
                  , ve = function(t, i) {
                    const n = r(t);
                    this._settings = n,
                    this.loadingCount = 0,
                    ((e,t)=>{
                        ce(e) || (t._observer = new IntersectionObserver((i=>{
                            ue(i, e, t)
                        }
                        ),(e=>({
                            root: e.container === document ? null : e.container,
                            rootMargin: e.thresholds || e.threshold + "px"
                        }))(e)))
                    }
                    )(n, this),
                    ((t,i)=>{
                        e && (i._onlineHandler = ()=>{
                            ((e,t)=>{
                                var i;
                                (i = fe(e),
                                pe(i).filter(he)).forEach((t=>{
                                    M(t, e.class_error),
                                    E(t)
                                }
                                )),
                                t.update()
                            }
                            )(t, i)
                        }
                        ,
                        window.addEventListener("online", i._onlineHandler))
                    }
                    )(n, this),
                    this.update(i)
                };
                return ve.prototype = {
                    update: function(e) {
                        const i = this._settings
                          , n = me(e, i);
                        var r, s;
                        _(this, n.length),
                        t ? this.loadAll(n) : ce(i) ? ((e,t,i)=>{
                            e.forEach((e=>{
                                -1 !== de.indexOf(e.tagName) && ((e,t,i)=>{
                                    e.setAttribute("loading", "lazy"),
                                    ne(e, t, i),
                                    ((e,t)=>{
                                        const i = U[e.tagName];
                                        i && i(e, t)
                                    }
                                    )(e, t),
                                    x(e, v)
                                }
                                )(e, t, i)
                            }
                            )),
                            _(i, 0)
                        }
                        )(n, i, this) : (s = n,
                        (e=>{
                            e.disconnect()
                        }
                        )(r = this._observer),
                        ((e,t)=>{
                            t.forEach((t=>{
                                e.observe(t)
                            }
                            ))
                        }
                        )(r, s))
                    },
                    destroy: function() {
                        this._observer && this._observer.disconnect(),
                        e && window.removeEventListener("online", this._onlineHandler),
                        fe(this._settings).forEach((e=>{
                            $(e)
                        }
                        )),
                        delete this._observer,
                        delete this._settings,
                        delete this._onlineHandler,
                        delete this.loadingCount,
                        delete this.toLoadCount
                    },
                    loadAll: function(e) {
                        const t = this._settings;
                        me(e, t).forEach((e=>{
                            k(e, this),
                            re(e, t, this)
                        }
                        ))
                    },
                    restoreAll: function() {
                        const e = this._settings;
                        fe(e).forEach((t=>{
                            le(t, e)
                        }
                        ))
                    }
                },
                ve.load = (e,t)=>{
                    const i = r(t);
                    re(e, i)
                }
                ,
                ve.resetStatus = e=>{
                    E(e)
                }
                ,
                e && ((e,t)=>{
                    if (t)
                        if (t.length)
                            for (let i, n = 0; i = t[n]; n += 1)
                                s(e, i);
                        else
                            s(e, t)
                }
                )(ve, window.lazyLoadOptions),
                ve
            }()
        }
    }
      , t = {};
    function i(n) {
        var r = t[n];
        if (void 0 !== r)
            return r.exports;
        var s = t[n] = {
            exports: {}
        };
        return e[n].call(s.exports, s, s.exports, i),
        s.exports
    }
    (()=>{
        "use strict";
        const e = {};
        function t() {
            if (location.hash)
                return location.hash.replace("#", "")
        }
        let n = (e,t=500,i=0)=>{
            e.classList.contains("_slide") || (e.classList.add("_slide"),
            e.style.transitionProperty = "height, margin, padding",
            e.style.transitionDuration = t + "ms",
            e.style.height = `${e.offsetHeight}px`,
            e.offsetHeight,
            e.style.overflow = "hidden",
            e.style.height = i ? `${i}px` : "0px",
            e.style.paddingTop = 0,
            e.style.paddingBottom = 0,
            e.style.marginTop = 0,
            e.style.marginBottom = 0,
            window.setTimeout((()=>{
                e.hidden = !i,
                !i && e.style.removeProperty("height"),
                e.style.removeProperty("padding-top"),
                e.style.removeProperty("padding-bottom"),
                e.style.removeProperty("margin-top"),
                e.style.removeProperty("margin-bottom"),
                !i && e.style.removeProperty("overflow"),
                e.style.removeProperty("transition-duration"),
                e.style.removeProperty("transition-property"),
                e.classList.remove("_slide"),
                document.dispatchEvent(new CustomEvent("slideUpDone",{
                    detail: {
                        target: e
                    }
                }))
            }
            ), t))
        }
          , r = (e,t=500,i=0)=>{
            if (!e.classList.contains("_slide")) {
                e.classList.add("_slide"),
                e.hidden = !e.hidden && null,
                i && e.style.removeProperty("height");
                let n = e.offsetHeight;
                e.style.overflow = "hidden",
                e.style.height = i ? `${i}px` : "0px",
                e.style.paddingTop = 0,
                e.style.paddingBottom = 0,
                e.style.marginTop = 0,
                e.style.marginBottom = 0,
                e.offsetHeight,
                e.style.transitionProperty = "height, margin, padding",
                e.style.transitionDuration = t + "ms",
                e.style.height = n + "px",
                e.style.removeProperty("padding-top"),
                e.style.removeProperty("padding-bottom"),
                e.style.removeProperty("margin-top"),
                e.style.removeProperty("margin-bottom"),
                window.setTimeout((()=>{
                    e.style.removeProperty("height"),
                    e.style.removeProperty("overflow"),
                    e.style.removeProperty("transition-duration"),
                    e.style.removeProperty("transition-property"),
                    e.classList.remove("_slide"),
                    document.dispatchEvent(new CustomEvent("slideDownDone",{
                        detail: {
                            target: e
                        }
                    }))
                }
                ), t)
            }
        }
          , s = !0
          , o = (e=500)=>{
            if (s) {
                const t = document.querySelectorAll("[data-lp]");
                setTimeout((()=>{
                    t.forEach((e=>{
                        e.style.paddingRight = ""
                    }
                    )),
                    document.body.style.paddingRight = "",
                    document.documentElement.classList.remove("lock")
                }
                ), e),
                s = !1,
                setTimeout((function() {
                    s = !0
                }
                ), e)
            }
        }
          , a = (e=500)=>{
            if (s) {
                const t = document.querySelectorAll("[data-lp]")
                  , i = window.innerWidth - document.body.offsetWidth + "px";
                t.forEach((e=>{
                    e.style.paddingRight = i
                }
                )),
                document.body.style.paddingRight = i,
                document.documentElement.classList.add("lock"),
                s = !1,
                setTimeout((function() {
                    s = !0
                }
                ), e)
            }
        }
        ;
        function l() {
            o(),
            document.documentElement.classList.remove("menu-open")
        }
        function d(e) {
            setTimeout((()=>{
                window.FLS && console.log(e)
            }
            ), 0)
        }
        function c(e) {
            return e.filter((function(e, t, i) {
                return i.indexOf(e) === t
            }
            ))
        }
        function u(e, t) {
            const i = Array.from(e).filter((function(e, i, n) {
                if (e.dataset[t])
                    return e.dataset[t].split(",")[0]
            }
            ));
            if (i.length) {
                const e = [];
                i.forEach((i=>{
                    const n = {}
                      , r = i.dataset[t].split(",");
                    n.value = r[0],
                    n.type = r[1] ? r[1].trim() : "max",
                    n.item = i,
                    e.push(n)
                }
                ));
                let n = e.map((function(e) {
                    return "(" + e.type + "-width: " + e.value + "px)," + e.value + "," + e.type
                }
                ));
                n = c(n);
                const r = [];
                if (n.length)
                    return n.forEach((t=>{
                        const i = t.split(",")
                          , n = i[1]
                          , s = i[2]
                          , o = window.matchMedia(i[0])
                          , a = e.filter((function(e) {
                            if (e.value === n && e.type === s)
                                return !0
                        }
                        ));
                        r.push({
                            itemsArray: a,
                            matchMedia: o
                        })
                    }
                    )),
                    r
            }
        }
        e.mousePrlx = new class {
            constructor(e, t=null) {
                if (this.config = Object.assign({
                    init: !0,
                    logging: !0
                }, e),
                this.config.init) {
                    const e = document.querySelectorAll("[data-prlx-mouse]");
                    e.length ? (this.paralaxMouseInit(e),
                    this.setLogging(`Прокинувся, стежу за об'єктами: (${e.length})`)) : this.setLogging("Немає жодного обєкта. Сплю...")
                }
            }
            paralaxMouseInit(e) {
                e.forEach((e=>{
                    const t = e.closest("[data-prlx-mouse-wrapper]")
                      , i = e.dataset.prlxCx ? +e.dataset.prlxCx : 100
                      , n = e.dataset.prlxCy ? +e.dataset.prlxCy : 100
                      , r = e.hasAttribute("data-prlx-dxr") ? -1 : 1
                      , s = e.hasAttribute("data-prlx-dyr") ? -1 : 1
                      , o = e.dataset.prlxA ? +e.dataset.prlxA : 50;
                    let a = 0
                      , l = 0
                      , d = 0
                      , c = 0;
                    function u(t=window) {
                        t.addEventListener("mousemove", (function(t) {
                            const i = e.getBoundingClientRect().top + window.scrollY;
                            if (i >= window.scrollY || i + e.offsetHeight >= window.scrollY) {
                                const e = window.innerWidth
                                  , i = window.innerHeight
                                  , n = t.clientX - e / 2
                                  , r = t.clientY - i / 2;
                                d = n / e * 100,
                                c = r / i * 100
                            }
                        }
                        ))
                    }
                    !function t() {
                        a += (d - a) * o / 1e3,
                        l += (c - l) * o / 1e3,
                        e.style.cssText = `transform: translate3D(${r * a / (i / 10)}%,${s * l / (n / 10)}%,0) rotate(0.02deg);`,
                        requestAnimationFrame(t)
                    }(),
                    t ? u(t) : u()
                }
                ))
            }
            setLogging(e) {
                this.config.logging && d(`[PRLX Mouse]: ${e}`)
            }
        }
        ({});
        let p = (e,t=!1,i=500,n=0)=>{
            const r = document.querySelector(e);
            if (r) {
                let s = ""
                  , o = 0;
                if (t) {
                    s = "header.header";
                    const e = document.querySelector(s);
                    e.classList.contains("_header-scroll") ? o = e.offsetHeight : (e.style.cssText = "transition-duration: 0s;",
                    e.classList.add("_header-scroll"),
                    o = e.offsetHeight,
                    e.classList.remove("_header-scroll"),
                    setTimeout((()=>{
                        e.style.cssText = ""
                    }
                    ), 0))
                }
                let a = {
                    speedAsDuration: !0,
                    speed: i,
                    header: s,
                    offset: n,
                    easing: "easeOutQuad"
                };
                if (document.documentElement.classList.contains("menu-open") && l(),
                "undefined" != typeof SmoothScroll)
                    (new SmoothScroll).animateScroll(r, "", a);
                else {
                    let e = r.getBoundingClientRect().top + scrollY;
                    e = o ? e - o : e,
                    e = n ? e - n : e,
                    window.scrollTo({
                        top: e,
                        behavior: "smooth"
                    })
                }
                d(`[gotoBlock]: Юхуу...їдемо до ${e}`)
            } else
                d(`[gotoBlock]: Йой... Такого блоку немає на сторінці: ${e}`)
        }
        ;
        function f(e) {
            if (null == e)
                return window;
            if ("[object Window]" !== e.toString()) {
                var t = e.ownerDocument;
                return t && t.defaultView || window
            }
            return e
        }
        function h(e) {
            return e instanceof f(e).Element || e instanceof Element
        }
        function m(e) {
            return e instanceof f(e).HTMLElement || e instanceof HTMLElement
        }
        function v(e) {
            return "undefined" != typeof ShadowRoot && (e instanceof f(e).ShadowRoot || e instanceof ShadowRoot)
        }
        var g = Math.max
          , w = Math.min
          , b = Math.round;
        function y() {
            var e = navigator.userAgentData;
            return null != e && e.brands && Array.isArray(e.brands) ? e.brands.map((function(e) {
                return e.brand + "/" + e.version
            }
            )).join(" ") : navigator.userAgent
        }
        function x() {
            return !/^((?!chrome|android).)*safari/i.test(y())
        }
        function E(e, t, i) {
            void 0 === t && (t = !1),
            void 0 === i && (i = !1);
            var n = e.getBoundingClientRect()
              , r = 1
              , s = 1;
            t && m(e) && (r = e.offsetWidth > 0 && b(n.width) / e.offsetWidth || 1,
            s = e.offsetHeight > 0 && b(n.height) / e.offsetHeight || 1);
            var o = (h(e) ? f(e) : window).visualViewport
              , a = !x() && i
              , l = (n.left + (a && o ? o.offsetLeft : 0)) / r
              , d = (n.top + (a && o ? o.offsetTop : 0)) / s
              , c = n.width / r
              , u = n.height / s;
            return {
                width: c,
                height: u,
                top: d,
                right: l + c,
                bottom: d + u,
                left: l,
                x: l,
                y: d
            }
        }
        function S(e) {
            var t = f(e);
            return {
                scrollLeft: t.pageXOffset,
                scrollTop: t.pageYOffset
            }
        }
        function T(e) {
            return e ? (e.nodeName || "").toLowerCase() : null
        }
        function L(e) {
            return ((h(e) ? e.ownerDocument : e.document) || window.document).documentElement
        }
        function C(e) {
            return E(L(e)).left + S(e).scrollLeft
        }
        function A(e) {
            return f(e).getComputedStyle(e)
        }
        function M(e) {
            var t = A(e)
              , i = t.overflow
              , n = t.overflowX
              , r = t.overflowY;
            return /auto|scroll|overlay|hidden/.test(i + r + n)
        }
        function O(e, t, i) {
            void 0 === i && (i = !1);
            var n, r, s = m(t), o = m(t) && function(e) {
                var t = e.getBoundingClientRect()
                  , i = b(t.width) / e.offsetWidth || 1
                  , n = b(t.height) / e.offsetHeight || 1;
                return 1 !== i || 1 !== n
            }(t), a = L(t), l = E(e, o, i), d = {
                scrollLeft: 0,
                scrollTop: 0
            }, c = {
                x: 0,
                y: 0
            };
            return (s || !s && !i) && (("body" !== T(t) || M(a)) && (d = (n = t) !== f(n) && m(n) ? {
                scrollLeft: (r = n).scrollLeft,
                scrollTop: r.scrollTop
            } : S(n)),
            m(t) ? ((c = E(t, !0)).x += t.clientLeft,
            c.y += t.clientTop) : a && (c.x = C(a))),
            {
                x: l.left + d.scrollLeft - c.x,
                y: l.top + d.scrollTop - c.y,
                width: l.width,
                height: l.height
            }
        }
        function k(e) {
            var t = E(e)
              , i = e.offsetWidth
              , n = e.offsetHeight;
            return Math.abs(t.width - i) <= 1 && (i = t.width),
            Math.abs(t.height - n) <= 1 && (n = t.height),
            {
                x: e.offsetLeft,
                y: e.offsetTop,
                width: i,
                height: n
            }
        }
        function P(e) {
            return "html" === T(e) ? e : e.assignedSlot || e.parentNode || (v(e) ? e.host : null) || L(e)
        }
        function _(e) {
            return ["html", "body", "#document"].indexOf(T(e)) >= 0 ? e.ownerDocument.body : m(e) && M(e) ? e : _(P(e))
        }
        function I(e, t) {
            var i;
            void 0 === t && (t = []);
            var n = _(e)
              , r = n === (null == (i = e.ownerDocument) ? void 0 : i.body)
              , s = f(n)
              , o = r ? [s].concat(s.visualViewport || [], M(n) ? n : []) : n
              , a = t.concat(o);
            return r ? a : a.concat(I(P(o)))
        }
        function D(e) {
            return ["table", "td", "th"].indexOf(T(e)) >= 0
        }
        function z(e) {
            return m(e) && "fixed" !== A(e).position ? e.offsetParent : null
        }
        function N(e) {
            for (var t = f(e), i = z(e); i && D(i) && "static" === A(i).position; )
                i = z(i);
            return i && ("html" === T(i) || "body" === T(i) && "static" === A(i).position) ? t : i || function(e) {
                var t = /firefox/i.test(y());
                if (/Trident/i.test(y()) && m(e) && "fixed" === A(e).position)
                    return null;
                var i = P(e);
                for (v(i) && (i = i.host); m(i) && ["html", "body"].indexOf(T(i)) < 0; ) {
                    var n = A(i);
                    if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || t && "filter" === n.willChange || t && n.filter && "none" !== n.filter)
                        return i;
                    i = i.parentNode
                }
                return null
            }(e) || t
        }
        var V = "top"
          , W = "bottom"
          , j = "right"
          , G = "left"
          , B = "auto"
          , $ = [V, W, j, G]
          , H = "start"
          , R = "end"
          , F = "clippingParents"
          , q = "viewport"
          , Y = "popper"
          , X = "reference"
          , U = $.reduce((function(e, t) {
            return e.concat([t + "-" + H, t + "-" + R])
        }
        ), [])
          , K = [].concat($, [B]).reduce((function(e, t) {
            return e.concat([t, t + "-" + H, t + "-" + R])
        }
        ), [])
          , J = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
        function Q(e) {
            var t = new Map
              , i = new Set
              , n = [];
            function r(e) {
                i.add(e.name),
                [].concat(e.requires || [], e.requiresIfExists || []).forEach((function(e) {
                    if (!i.has(e)) {
                        var n = t.get(e);
                        n && r(n)
                    }
                }
                )),
                n.push(e)
            }
            return e.forEach((function(e) {
                t.set(e.name, e)
            }
            )),
            e.forEach((function(e) {
                i.has(e.name) || r(e)
            }
            )),
            n
        }
        var Z = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
        };
        function ee() {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                t[i] = arguments[i];
            return !t.some((function(e) {
                return !(e && "function" == typeof e.getBoundingClientRect)
            }
            ))
        }
        function te(e) {
            void 0 === e && (e = {});
            var t = e
              , i = t.defaultModifiers
              , n = void 0 === i ? [] : i
              , r = t.defaultOptions
              , s = void 0 === r ? Z : r;
            return function(e, t, i) {
                void 0 === i && (i = s);
                var r, o, a = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign({}, Z, s),
                    modifiersData: {},
                    elements: {
                        reference: e,
                        popper: t
                    },
                    attributes: {},
                    styles: {}
                }, l = [], d = !1, c = {
                    state: a,
                    setOptions: function(i) {
                        var r = "function" == typeof i ? i(a.options) : i;
                        u(),
                        a.options = Object.assign({}, s, a.options, r),
                        a.scrollParents = {
                            reference: h(e) ? I(e) : e.contextElement ? I(e.contextElement) : [],
                            popper: I(t)
                        };
                        var o, d, p = function(e) {
                            var t = Q(e);
                            return J.reduce((function(e, i) {
                                return e.concat(t.filter((function(e) {
                                    return e.phase === i
                                }
                                )))
                            }
                            ), [])
                        }((o = [].concat(n, a.options.modifiers),
                        d = o.reduce((function(e, t) {
                            var i = e[t.name];
                            return e[t.name] = i ? Object.assign({}, i, t, {
                                options: Object.assign({}, i.options, t.options),
                                data: Object.assign({}, i.data, t.data)
                            }) : t,
                            e
                        }
                        ), {}),
                        Object.keys(d).map((function(e) {
                            return d[e]
                        }
                        ))));
                        return a.orderedModifiers = p.filter((function(e) {
                            return e.enabled
                        }
                        )),
                        a.orderedModifiers.forEach((function(e) {
                            var t = e.name
                              , i = e.options
                              , n = void 0 === i ? {} : i
                              , r = e.effect;
                            if ("function" == typeof r) {
                                var s = r({
                                    state: a,
                                    name: t,
                                    instance: c,
                                    options: n
                                })
                                  , o = function() {};
                                l.push(s || o)
                            }
                        }
                        )),
                        c.update()
                    },
                    forceUpdate: function() {
                        if (!d) {
                            var e = a.elements
                              , t = e.reference
                              , i = e.popper;
                            if (ee(t, i)) {
                                a.rects = {
                                    reference: O(t, N(i), "fixed" === a.options.strategy),
                                    popper: k(i)
                                },
                                a.reset = !1,
                                a.placement = a.options.placement,
                                a.orderedModifiers.forEach((function(e) {
                                    return a.modifiersData[e.name] = Object.assign({}, e.data)
                                }
                                ));
                                for (var n = 0; n < a.orderedModifiers.length; n++)
                                    if (!0 !== a.reset) {
                                        var r = a.orderedModifiers[n]
                                          , s = r.fn
                                          , o = r.options
                                          , l = void 0 === o ? {} : o
                                          , u = r.name;
                                        "function" == typeof s && (a = s({
                                            state: a,
                                            options: l,
                                            name: u,
                                            instance: c
                                        }) || a)
                                    } else
                                        a.reset = !1,
                                        n = -1
                            }
                        }
                    },
                    update: (r = function() {
                        return new Promise((function(e) {
                            c.forceUpdate(),
                            e(a)
                        }
                        ))
                    }
                    ,
                    function() {
                        return o || (o = new Promise((function(e) {
                            Promise.resolve().then((function() {
                                o = void 0,
                                e(r())
                            }
                            ))
                        }
                        ))),
                        o
                    }
                    ),
                    destroy: function() {
                        u(),
                        d = !0
                    }
                };
                if (!ee(e, t))
                    return c;
                function u() {
                    l.forEach((function(e) {
                        return e()
                    }
                    )),
                    l = []
                }
                return c.setOptions(i).then((function(e) {
                    !d && i.onFirstUpdate && i.onFirstUpdate(e)
                }
                )),
                c
            }
        }
        var ie = {
            passive: !0
        };
        function ne(e) {
            return e.split("-")[0]
        }
        function re(e) {
            return e.split("-")[1]
        }
        function se(e) {
            return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
        }
        function oe(e) {
            var t, i = e.reference, n = e.element, r = e.placement, s = r ? ne(r) : null, o = r ? re(r) : null, a = i.x + i.width / 2 - n.width / 2, l = i.y + i.height / 2 - n.height / 2;
            switch (s) {
            case V:
                t = {
                    x: a,
                    y: i.y - n.height
                };
                break;
            case W:
                t = {
                    x: a,
                    y: i.y + i.height
                };
                break;
            case j:
                t = {
                    x: i.x + i.width,
                    y: l
                };
                break;
            case G:
                t = {
                    x: i.x - n.width,
                    y: l
                };
                break;
            default:
                t = {
                    x: i.x,
                    y: i.y
                }
            }
            var d = s ? se(s) : null;
            if (null != d) {
                var c = "y" === d ? "height" : "width";
                switch (o) {
                case H:
                    t[d] = t[d] - (i[c] / 2 - n[c] / 2);
                    break;
                case R:
                    t[d] = t[d] + (i[c] / 2 - n[c] / 2)
                }
            }
            return t
        }
        var ae = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };
        function le(e) {
            var t, i = e.popper, n = e.popperRect, r = e.placement, s = e.variation, o = e.offsets, a = e.position, l = e.gpuAcceleration, d = e.adaptive, c = e.roundOffsets, u = e.isFixed, p = o.x, h = void 0 === p ? 0 : p, m = o.y, v = void 0 === m ? 0 : m, g = "function" == typeof c ? c({
                x: h,
                y: v
            }) : {
                x: h,
                y: v
            };
            h = g.x,
            v = g.y;
            var w = o.hasOwnProperty("x")
              , y = o.hasOwnProperty("y")
              , x = G
              , E = V
              , S = window;
            if (d) {
                var T = N(i)
                  , C = "clientHeight"
                  , M = "clientWidth";
                if (T === f(i) && "static" !== A(T = L(i)).position && "absolute" === a && (C = "scrollHeight",
                M = "scrollWidth"),
                r === V || (r === G || r === j) && s === R)
                    E = W,
                    v -= (u && T === S && S.visualViewport ? S.visualViewport.height : T[C]) - n.height,
                    v *= l ? 1 : -1;
                if (r === G || (r === V || r === W) && s === R)
                    x = j,
                    h -= (u && T === S && S.visualViewport ? S.visualViewport.width : T[M]) - n.width,
                    h *= l ? 1 : -1
            }
            var O, k = Object.assign({
                position: a
            }, d && ae), P = !0 === c ? function(e, t) {
                var i = e.x
                  , n = e.y
                  , r = t.devicePixelRatio || 1;
                return {
                    x: b(i * r) / r || 0,
                    y: b(n * r) / r || 0
                }
            }({
                x: h,
                y: v
            }, f(i)) : {
                x: h,
                y: v
            };
            return h = P.x,
            v = P.y,
            l ? Object.assign({}, k, ((O = {})[E] = y ? "0" : "",
            O[x] = w ? "0" : "",
            O.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + v + "px)" : "translate3d(" + h + "px, " + v + "px, 0)",
            O)) : Object.assign({}, k, ((t = {})[E] = y ? v + "px" : "",
            t[x] = w ? h + "px" : "",
            t.transform = "",
            t))
        }
        const de = {
            name: "applyStyles",
            enabled: !0,
            phase: "write",
            fn: function(e) {
                var t = e.state;
                Object.keys(t.elements).forEach((function(e) {
                    var i = t.styles[e] || {}
                      , n = t.attributes[e] || {}
                      , r = t.elements[e];
                    m(r) && T(r) && (Object.assign(r.style, i),
                    Object.keys(n).forEach((function(e) {
                        var t = n[e];
                        !1 === t ? r.removeAttribute(e) : r.setAttribute(e, !0 === t ? "" : t)
                    }
                    )))
                }
                ))
            },
            effect: function(e) {
                var t = e.state
                  , i = {
                    popper: {
                        position: t.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
                return Object.assign(t.elements.popper.style, i.popper),
                t.styles = i,
                t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow),
                function() {
                    Object.keys(t.elements).forEach((function(e) {
                        var n = t.elements[e]
                          , r = t.attributes[e] || {}
                          , s = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce((function(e, t) {
                            return e[t] = "",
                            e
                        }
                        ), {});
                        m(n) && T(n) && (Object.assign(n.style, s),
                        Object.keys(r).forEach((function(e) {
                            n.removeAttribute(e)
                        }
                        )))
                    }
                    ))
                }
            },
            requires: ["computeStyles"]
        };
        const ce = {
            name: "offset",
            enabled: !0,
            phase: "main",
            requires: ["popperOffsets"],
            fn: function(e) {
                var t = e.state
                  , i = e.options
                  , n = e.name
                  , r = i.offset
                  , s = void 0 === r ? [0, 0] : r
                  , o = K.reduce((function(e, i) {
                    return e[i] = function(e, t, i) {
                        var n = ne(e)
                          , r = [G, V].indexOf(n) >= 0 ? -1 : 1
                          , s = "function" == typeof i ? i(Object.assign({}, t, {
                            placement: e
                        })) : i
                          , o = s[0]
                          , a = s[1];
                        return o = o || 0,
                        a = (a || 0) * r,
                        [G, j].indexOf(n) >= 0 ? {
                            x: a,
                            y: o
                        } : {
                            x: o,
                            y: a
                        }
                    }(i, t.rects, s),
                    e
                }
                ), {})
                  , a = o[t.placement]
                  , l = a.x
                  , d = a.y;
                null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l,
                t.modifiersData.popperOffsets.y += d),
                t.modifiersData[n] = o
            }
        };
        var ue = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };
        function pe(e) {
            return e.replace(/left|right|bottom|top/g, (function(e) {
                return ue[e]
            }
            ))
        }
        var fe = {
            start: "end",
            end: "start"
        };
        function he(e) {
            return e.replace(/start|end/g, (function(e) {
                return fe[e]
            }
            ))
        }
        function me(e, t) {
            var i = t.getRootNode && t.getRootNode();
            if (e.contains(t))
                return !0;
            if (i && v(i)) {
                var n = t;
                do {
                    if (n && e.isSameNode(n))
                        return !0;
                    n = n.parentNode || n.host
                } while (n)
            }
            return !1
        }
        function ve(e) {
            return Object.assign({}, e, {
                left: e.x,
                top: e.y,
                right: e.x + e.width,
                bottom: e.y + e.height
            })
        }
        function ge(e, t, i) {
            return t === q ? ve(function(e, t) {
                var i = f(e)
                  , n = L(e)
                  , r = i.visualViewport
                  , s = n.clientWidth
                  , o = n.clientHeight
                  , a = 0
                  , l = 0;
                if (r) {
                    s = r.width,
                    o = r.height;
                    var d = x();
                    (d || !d && "fixed" === t) && (a = r.offsetLeft,
                    l = r.offsetTop)
                }
                return {
                    width: s,
                    height: o,
                    x: a + C(e),
                    y: l
                }
            }(e, i)) : h(t) ? function(e, t) {
                var i = E(e, !1, "fixed" === t);
                return i.top = i.top + e.clientTop,
                i.left = i.left + e.clientLeft,
                i.bottom = i.top + e.clientHeight,
                i.right = i.left + e.clientWidth,
                i.width = e.clientWidth,
                i.height = e.clientHeight,
                i.x = i.left,
                i.y = i.top,
                i
            }(t, i) : ve(function(e) {
                var t, i = L(e), n = S(e), r = null == (t = e.ownerDocument) ? void 0 : t.body, s = g(i.scrollWidth, i.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), o = g(i.scrollHeight, i.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -n.scrollLeft + C(e), l = -n.scrollTop;
                return "rtl" === A(r || i).direction && (a += g(i.clientWidth, r ? r.clientWidth : 0) - s),
                {
                    width: s,
                    height: o,
                    x: a,
                    y: l
                }
            }(L(e)))
        }
        function we(e, t, i, n) {
            var r = "clippingParents" === t ? function(e) {
                var t = I(P(e))
                  , i = ["absolute", "fixed"].indexOf(A(e).position) >= 0 && m(e) ? N(e) : e;
                return h(i) ? t.filter((function(e) {
                    return h(e) && me(e, i) && "body" !== T(e)
                }
                )) : []
            }(e) : [].concat(t)
              , s = [].concat(r, [i])
              , o = s[0]
              , a = s.reduce((function(t, i) {
                var r = ge(e, i, n);
                return t.top = g(r.top, t.top),
                t.right = w(r.right, t.right),
                t.bottom = w(r.bottom, t.bottom),
                t.left = g(r.left, t.left),
                t
            }
            ), ge(e, o, n));
            return a.width = a.right - a.left,
            a.height = a.bottom - a.top,
            a.x = a.left,
            a.y = a.top,
            a
        }
        function be(e) {
            return Object.assign({}, {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }, e)
        }
        function ye(e, t) {
            return t.reduce((function(t, i) {
                return t[i] = e,
                t
            }
            ), {})
        }
        function xe(e, t) {
            void 0 === t && (t = {});
            var i = t
              , n = i.placement
              , r = void 0 === n ? e.placement : n
              , s = i.strategy
              , o = void 0 === s ? e.strategy : s
              , a = i.boundary
              , l = void 0 === a ? F : a
              , d = i.rootBoundary
              , c = void 0 === d ? q : d
              , u = i.elementContext
              , p = void 0 === u ? Y : u
              , f = i.altBoundary
              , m = void 0 !== f && f
              , v = i.padding
              , g = void 0 === v ? 0 : v
              , w = be("number" != typeof g ? g : ye(g, $))
              , b = p === Y ? X : Y
              , y = e.rects.popper
              , x = e.elements[m ? b : p]
              , S = we(h(x) ? x : x.contextElement || L(e.elements.popper), l, c, o)
              , T = E(e.elements.reference)
              , C = oe({
                reference: T,
                element: y,
                strategy: "absolute",
                placement: r
            })
              , A = ve(Object.assign({}, y, C))
              , M = p === Y ? A : T
              , O = {
                top: S.top - M.top + w.top,
                bottom: M.bottom - S.bottom + w.bottom,
                left: S.left - M.left + w.left,
                right: M.right - S.right + w.right
            }
              , k = e.modifiersData.offset;
            if (p === Y && k) {
                var P = k[r];
                Object.keys(O).forEach((function(e) {
                    var t = [j, W].indexOf(e) >= 0 ? 1 : -1
                      , i = [V, W].indexOf(e) >= 0 ? "y" : "x";
                    O[e] += P[i] * t
                }
                ))
            }
            return O
        }
        function Ee(e, t, i) {
            return g(e, w(t, i))
        }
        const Se = {
            name: "preventOverflow",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t = e.state
                  , i = e.options
                  , n = e.name
                  , r = i.mainAxis
                  , s = void 0 === r || r
                  , o = i.altAxis
                  , a = void 0 !== o && o
                  , l = i.boundary
                  , d = i.rootBoundary
                  , c = i.altBoundary
                  , u = i.padding
                  , p = i.tether
                  , f = void 0 === p || p
                  , h = i.tetherOffset
                  , m = void 0 === h ? 0 : h
                  , v = xe(t, {
                    boundary: l,
                    rootBoundary: d,
                    padding: u,
                    altBoundary: c
                })
                  , b = ne(t.placement)
                  , y = re(t.placement)
                  , x = !y
                  , E = se(b)
                  , S = "x" === E ? "y" : "x"
                  , T = t.modifiersData.popperOffsets
                  , L = t.rects.reference
                  , C = t.rects.popper
                  , A = "function" == typeof m ? m(Object.assign({}, t.rects, {
                    placement: t.placement
                })) : m
                  , M = "number" == typeof A ? {
                    mainAxis: A,
                    altAxis: A
                } : Object.assign({
                    mainAxis: 0,
                    altAxis: 0
                }, A)
                  , O = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null
                  , P = {
                    x: 0,
                    y: 0
                };
                if (T) {
                    if (s) {
                        var _, I = "y" === E ? V : G, D = "y" === E ? W : j, z = "y" === E ? "height" : "width", B = T[E], $ = B + v[I], R = B - v[D], F = f ? -C[z] / 2 : 0, q = y === H ? L[z] : C[z], Y = y === H ? -C[z] : -L[z], X = t.elements.arrow, U = f && X ? k(X) : {
                            width: 0,
                            height: 0
                        }, K = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }, J = K[I], Q = K[D], Z = Ee(0, L[z], U[z]), ee = x ? L[z] / 2 - F - Z - J - M.mainAxis : q - Z - J - M.mainAxis, te = x ? -L[z] / 2 + F + Z + Q + M.mainAxis : Y + Z + Q + M.mainAxis, ie = t.elements.arrow && N(t.elements.arrow), oe = ie ? "y" === E ? ie.clientTop || 0 : ie.clientLeft || 0 : 0, ae = null != (_ = null == O ? void 0 : O[E]) ? _ : 0, le = B + te - ae, de = Ee(f ? w($, B + ee - ae - oe) : $, B, f ? g(R, le) : R);
                        T[E] = de,
                        P[E] = de - B
                    }
                    if (a) {
                        var ce, ue = "x" === E ? V : G, pe = "x" === E ? W : j, fe = T[S], he = "y" === S ? "height" : "width", me = fe + v[ue], ve = fe - v[pe], ge = -1 !== [V, G].indexOf(b), we = null != (ce = null == O ? void 0 : O[S]) ? ce : 0, be = ge ? me : fe - L[he] - C[he] - we + M.altAxis, ye = ge ? fe + L[he] + C[he] - we - M.altAxis : ve, Se = f && ge ? function(e, t, i) {
                            var n = Ee(e, t, i);
                            return n > i ? i : n
                        }(be, fe, ye) : Ee(f ? be : me, fe, f ? ye : ve);
                        T[S] = Se,
                        P[S] = Se - fe
                    }
                    t.modifiersData[n] = P
                }
            },
            requiresIfExists: ["offset"]
        };
        const Te = {
            name: "arrow",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t, i = e.state, n = e.name, r = e.options, s = i.elements.arrow, o = i.modifiersData.popperOffsets, a = ne(i.placement), l = se(a), d = [G, j].indexOf(a) >= 0 ? "height" : "width";
                if (s && o) {
                    var c = function(e, t) {
                        return be("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, {
                            placement: t.placement
                        })) : e) ? e : ye(e, $))
                    }(r.padding, i)
                      , u = k(s)
                      , p = "y" === l ? V : G
                      , f = "y" === l ? W : j
                      , h = i.rects.reference[d] + i.rects.reference[l] - o[l] - i.rects.popper[d]
                      , m = o[l] - i.rects.reference[l]
                      , v = N(s)
                      , g = v ? "y" === l ? v.clientHeight || 0 : v.clientWidth || 0 : 0
                      , w = h / 2 - m / 2
                      , b = c[p]
                      , y = g - u[d] - c[f]
                      , x = g / 2 - u[d] / 2 + w
                      , E = Ee(b, x, y)
                      , S = l;
                    i.modifiersData[n] = ((t = {})[S] = E,
                    t.centerOffset = E - x,
                    t)
                }
            },
            effect: function(e) {
                var t = e.state
                  , i = e.options.element
                  , n = void 0 === i ? "[data-popper-arrow]" : i;
                null != n && ("string" != typeof n || (n = t.elements.popper.querySelector(n))) && me(t.elements.popper, n) && (t.elements.arrow = n)
            },
            requires: ["popperOffsets"],
            requiresIfExists: ["preventOverflow"]
        };
        function Le(e, t, i) {
            return void 0 === i && (i = {
                x: 0,
                y: 0
            }),
            {
                top: e.top - t.height - i.y,
                right: e.right - t.width + i.x,
                bottom: e.bottom - t.height + i.y,
                left: e.left - t.width - i.x
            }
        }
        function Ce(e) {
            return [V, j, W, G].some((function(t) {
                return e[t] >= 0
            }
            ))
        }
        var Ae = te({
            defaultModifiers: [{
                name: "eventListeners",
                enabled: !0,
                phase: "write",
                fn: function() {},
                effect: function(e) {
                    var t = e.state
                      , i = e.instance
                      , n = e.options
                      , r = n.scroll
                      , s = void 0 === r || r
                      , o = n.resize
                      , a = void 0 === o || o
                      , l = f(t.elements.popper)
                      , d = [].concat(t.scrollParents.reference, t.scrollParents.popper);
                    return s && d.forEach((function(e) {
                        e.addEventListener("scroll", i.update, ie)
                    }
                    )),
                    a && l.addEventListener("resize", i.update, ie),
                    function() {
                        s && d.forEach((function(e) {
                            e.removeEventListener("scroll", i.update, ie)
                        }
                        )),
                        a && l.removeEventListener("resize", i.update, ie)
                    }
                },
                data: {}
            }, {
                name: "popperOffsets",
                enabled: !0,
                phase: "read",
                fn: function(e) {
                    var t = e.state
                      , i = e.name;
                    t.modifiersData[i] = oe({
                        reference: t.rects.reference,
                        element: t.rects.popper,
                        strategy: "absolute",
                        placement: t.placement
                    })
                },
                data: {}
            }, {
                name: "computeStyles",
                enabled: !0,
                phase: "beforeWrite",
                fn: function(e) {
                    var t = e.state
                      , i = e.options
                      , n = i.gpuAcceleration
                      , r = void 0 === n || n
                      , s = i.adaptive
                      , o = void 0 === s || s
                      , a = i.roundOffsets
                      , l = void 0 === a || a
                      , d = {
                        placement: ne(t.placement),
                        variation: re(t.placement),
                        popper: t.elements.popper,
                        popperRect: t.rects.popper,
                        gpuAcceleration: r,
                        isFixed: "fixed" === t.options.strategy
                    };
                    null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, le(Object.assign({}, d, {
                        offsets: t.modifiersData.popperOffsets,
                        position: t.options.strategy,
                        adaptive: o,
                        roundOffsets: l
                    })))),
                    null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, le(Object.assign({}, d, {
                        offsets: t.modifiersData.arrow,
                        position: "absolute",
                        adaptive: !1,
                        roundOffsets: l
                    })))),
                    t.attributes.popper = Object.assign({}, t.attributes.popper, {
                        "data-popper-placement": t.placement
                    })
                },
                data: {}
            }, de, ce, {
                name: "flip",
                enabled: !0,
                phase: "main",
                fn: function(e) {
                    var t = e.state
                      , i = e.options
                      , n = e.name;
                    if (!t.modifiersData[n]._skip) {
                        for (var r = i.mainAxis, s = void 0 === r || r, o = i.altAxis, a = void 0 === o || o, l = i.fallbackPlacements, d = i.padding, c = i.boundary, u = i.rootBoundary, p = i.altBoundary, f = i.flipVariations, h = void 0 === f || f, m = i.allowedAutoPlacements, v = t.options.placement, g = ne(v), w = l || (g === v || !h ? [pe(v)] : function(e) {
                            if (ne(e) === B)
                                return [];
                            var t = pe(e);
                            return [he(e), t, he(t)]
                        }(v)), b = [v].concat(w).reduce((function(e, i) {
                            return e.concat(ne(i) === B ? function(e, t) {
                                void 0 === t && (t = {});
                                var i = t
                                  , n = i.placement
                                  , r = i.boundary
                                  , s = i.rootBoundary
                                  , o = i.padding
                                  , a = i.flipVariations
                                  , l = i.allowedAutoPlacements
                                  , d = void 0 === l ? K : l
                                  , c = re(n)
                                  , u = c ? a ? U : U.filter((function(e) {
                                    return re(e) === c
                                }
                                )) : $
                                  , p = u.filter((function(e) {
                                    return d.indexOf(e) >= 0
                                }
                                ));
                                0 === p.length && (p = u);
                                var f = p.reduce((function(t, i) {
                                    return t[i] = xe(e, {
                                        placement: i,
                                        boundary: r,
                                        rootBoundary: s,
                                        padding: o
                                    })[ne(i)],
                                    t
                                }
                                ), {});
                                return Object.keys(f).sort((function(e, t) {
                                    return f[e] - f[t]
                                }
                                ))
                            }(t, {
                                placement: i,
                                boundary: c,
                                rootBoundary: u,
                                padding: d,
                                flipVariations: h,
                                allowedAutoPlacements: m
                            }) : i)
                        }
                        ), []), y = t.rects.reference, x = t.rects.popper, E = new Map, S = !0, T = b[0], L = 0; L < b.length; L++) {
                            var C = b[L]
                              , A = ne(C)
                              , M = re(C) === H
                              , O = [V, W].indexOf(A) >= 0
                              , k = O ? "width" : "height"
                              , P = xe(t, {
                                placement: C,
                                boundary: c,
                                rootBoundary: u,
                                altBoundary: p,
                                padding: d
                            })
                              , _ = O ? M ? j : G : M ? W : V;
                            y[k] > x[k] && (_ = pe(_));
                            var I = pe(_)
                              , D = [];
                            if (s && D.push(P[A] <= 0),
                            a && D.push(P[_] <= 0, P[I] <= 0),
                            D.every((function(e) {
                                return e
                            }
                            ))) {
                                T = C,
                                S = !1;
                                break
                            }
                            E.set(C, D)
                        }
                        if (S)
                            for (var z = function(e) {
                                var t = b.find((function(t) {
                                    var i = E.get(t);
                                    if (i)
                                        return i.slice(0, e).every((function(e) {
                                            return e
                                        }
                                        ))
                                }
                                ));
                                if (t)
                                    return T = t,
                                    "break"
                            }, N = h ? 3 : 1; N > 0; N--) {
                                if ("break" === z(N))
                                    break
                            }
                        t.placement !== T && (t.modifiersData[n]._skip = !0,
                        t.placement = T,
                        t.reset = !0)
                    }
                },
                requiresIfExists: ["offset"],
                data: {
                    _skip: !1
                }
            }, Se, Te, {
                name: "hide",
                enabled: !0,
                phase: "main",
                requiresIfExists: ["preventOverflow"],
                fn: function(e) {
                    var t = e.state
                      , i = e.name
                      , n = t.rects.reference
                      , r = t.rects.popper
                      , s = t.modifiersData.preventOverflow
                      , o = xe(t, {
                        elementContext: "reference"
                    })
                      , a = xe(t, {
                        altBoundary: !0
                    })
                      , l = Le(o, n)
                      , d = Le(a, r, s)
                      , c = Ce(l)
                      , u = Ce(d);
                    t.modifiersData[i] = {
                        referenceClippingOffsets: l,
                        popperEscapeOffsets: d,
                        isReferenceHidden: c,
                        hasPopperEscaped: u
                    },
                    t.attributes.popper = Object.assign({}, t.attributes.popper, {
                        "data-popper-reference-hidden": c,
                        "data-popper-escaped": u
                    })
                }
            }]
        })
          , Me = "tippy-content"
          , Oe = "tippy-backdrop"
          , ke = "tippy-arrow"
          , Pe = "tippy-svg-arrow"
          , _e = {
            passive: !0,
            capture: !0
        }
          , Ie = function() {
            return document.body
        };
        function De(e, t, i) {
            if (Array.isArray(e)) {
                var n = e[t];
                return null == n ? Array.isArray(i) ? i[t] : i : n
            }
            return e
        }
        function ze(e, t) {
            var i = {}.toString.call(e);
            return 0 === i.indexOf("[object") && i.indexOf(t + "]") > -1
        }
        function Ne(e, t) {
            return "function" == typeof e ? e.apply(void 0, t) : e
        }
        function Ve(e, t) {
            return 0 === t ? e : function(n) {
                clearTimeout(i),
                i = setTimeout((function() {
                    e(n)
                }
                ), t)
            }
            ;
            var i
        }
        function We(e) {
            return [].concat(e)
        }
        function je(e, t) {
            -1 === e.indexOf(t) && e.push(t)
        }
        function Ge(e) {
            return e.split("-")[0]
        }
        function Be(e) {
            return [].slice.call(e)
        }
        function $e(e) {
            return Object.keys(e).reduce((function(t, i) {
                return void 0 !== e[i] && (t[i] = e[i]),
                t
            }
            ), {})
        }
        function He() {
            return document.createElement("div")
        }
        function Re(e) {
            return ["Element", "Fragment"].some((function(t) {
                return ze(e, t)
            }
            ))
        }
        function Fe(e) {
            return ze(e, "MouseEvent")
        }
        function qe(e) {
            return !(!e || !e._tippy || e._tippy.reference !== e)
        }
        function Ye(e) {
            return Re(e) ? [e] : function(e) {
                return ze(e, "NodeList")
            }(e) ? Be(e) : Array.isArray(e) ? e : Be(document.querySelectorAll(e))
        }
        function Xe(e, t) {
            e.forEach((function(e) {
                e && (e.style.transitionDuration = t + "ms")
            }
            ))
        }
        function Ue(e, t) {
            e.forEach((function(e) {
                e && e.setAttribute("data-state", t)
            }
            ))
        }
        function Ke(e) {
            var t, i = We(e)[0];
            return null != i && null != (t = i.ownerDocument) && t.body ? i.ownerDocument : document
        }
        function Je(e, t, i) {
            var n = t + "EventListener";
            ["transitionend", "webkitTransitionEnd"].forEach((function(t) {
                e[n](t, i)
            }
            ))
        }
        function Qe(e, t) {
            for (var i = t; i; ) {
                var n;
                if (e.contains(i))
                    return !0;
                i = null == i.getRootNode || null == (n = i.getRootNode()) ? void 0 : n.host
            }
            return !1
        }
        var Ze = {
            isTouch: !1
        }
          , et = 0;
        function tt() {
            Ze.isTouch || (Ze.isTouch = !0,
            window.performance && document.addEventListener("mousemove", it))
        }
        function it() {
            var e = performance.now();
            e - et < 20 && (Ze.isTouch = !1,
            document.removeEventListener("mousemove", it)),
            et = e
        }
        function nt() {
            var e = document.activeElement;
            if (qe(e)) {
                var t = e._tippy;
                e.blur && !t.state.isVisible && e.blur()
            }
        }
        var rt = !!("undefined" != typeof window && "undefined" != typeof document) && !!window.msCrypto;
        var st = {
            animateFill: !1,
            followCursor: !1,
            inlinePositioning: !1,
            sticky: !1
        }
          , ot = Object.assign({
            appendTo: Ie,
            aria: {
                content: "auto",
                expanded: "auto"
            },
            delay: 0,
            duration: [300, 250],
            getReferenceClientRect: null,
            hideOnClick: !0,
            ignoreAttributes: !1,
            interactive: !1,
            interactiveBorder: 2,
            interactiveDebounce: 0,
            moveTransition: "",
            offset: [0, 10],
            onAfterUpdate: function() {},
            onBeforeUpdate: function() {},
            onCreate: function() {},
            onDestroy: function() {},
            onHidden: function() {},
            onHide: function() {},
            onMount: function() {},
            onShow: function() {},
            onShown: function() {},
            onTrigger: function() {},
            onUntrigger: function() {},
            onClickOutside: function() {},
            placement: "top",
            plugins: [],
            popperOptions: {},
            render: null,
            showOnCreate: !1,
            touch: !0,
            trigger: "mouseenter focus",
            triggerTarget: null
        }, st, {
            allowHTML: !1,
            animation: "fade",
            arrow: !0,
            content: "",
            inertia: !1,
            maxWidth: 350,
            role: "tooltip",
            theme: "",
            zIndex: 9999
        })
          , at = Object.keys(ot);
        function lt(e) {
            var t = (e.plugins || []).reduce((function(t, i) {
                var n, r = i.name, s = i.defaultValue;
                r && (t[r] = void 0 !== e[r] ? e[r] : null != (n = ot[r]) ? n : s);
                return t
            }
            ), {});
            return Object.assign({}, e, t)
        }
        function dt(e, t) {
            var i = Object.assign({}, t, {
                content: Ne(t.content, [e])
            }, t.ignoreAttributes ? {} : function(e, t) {
                return (t ? Object.keys(lt(Object.assign({}, ot, {
                    plugins: t
                }))) : at).reduce((function(t, i) {
                    var n = (e.getAttribute("data-tippy-" + i) || "").trim();
                    if (!n)
                        return t;
                    if ("content" === i)
                        t[i] = n;
                    else
                        try {
                            t[i] = JSON.parse(n)
                        } catch (e) {
                            t[i] = n
                        }
                    return t
                }
                ), {})
            }(e, t.plugins));
            return i.aria = Object.assign({}, ot.aria, i.aria),
            i.aria = {
                expanded: "auto" === i.aria.expanded ? t.interactive : i.aria.expanded,
                content: "auto" === i.aria.content ? t.interactive ? null : "describedby" : i.aria.content
            },
            i
        }
        var ct = function() {
            return "innerHTML"
        };
        function ut(e, t) {
            e[ct()] = t
        }
        function pt(e) {
            var t = He();
            return !0 === e ? t.className = ke : (t.className = Pe,
            Re(e) ? t.appendChild(e) : ut(t, e)),
            t
        }
        function ft(e, t) {
            Re(t.content) ? (ut(e, ""),
            e.appendChild(t.content)) : "function" != typeof t.content && (t.allowHTML ? ut(e, t.content) : e.textContent = t.content)
        }
        function ht(e) {
            var t = e.firstElementChild
              , i = Be(t.children);
            return {
                box: t,
                content: i.find((function(e) {
                    return e.classList.contains(Me)
                }
                )),
                arrow: i.find((function(e) {
                    return e.classList.contains(ke) || e.classList.contains(Pe)
                }
                )),
                backdrop: i.find((function(e) {
                    return e.classList.contains(Oe)
                }
                ))
            }
        }
        function mt(e) {
            var t = He()
              , i = He();
            i.className = "tippy-box",
            i.setAttribute("data-state", "hidden"),
            i.setAttribute("tabindex", "-1");
            var n = He();
            function r(i, n) {
                var r = ht(t)
                  , s = r.box
                  , o = r.content
                  , a = r.arrow;
                n.theme ? s.setAttribute("data-theme", n.theme) : s.removeAttribute("data-theme"),
                "string" == typeof n.animation ? s.setAttribute("data-animation", n.animation) : s.removeAttribute("data-animation"),
                n.inertia ? s.setAttribute("data-inertia", "") : s.removeAttribute("data-inertia"),
                s.style.maxWidth = "number" == typeof n.maxWidth ? n.maxWidth + "px" : n.maxWidth,
                n.role ? s.setAttribute("role", n.role) : s.removeAttribute("role"),
                i.content === n.content && i.allowHTML === n.allowHTML || ft(o, e.props),
                n.arrow ? a ? i.arrow !== n.arrow && (s.removeChild(a),
                s.appendChild(pt(n.arrow))) : s.appendChild(pt(n.arrow)) : a && s.removeChild(a)
            }
            return n.className = Me,
            n.setAttribute("data-state", "hidden"),
            ft(n, e.props),
            t.appendChild(i),
            i.appendChild(n),
            r(e.props, e.props),
            {
                popper: t,
                onUpdate: r
            }
        }
        mt.$$tippy = !0;
        var vt = 1
          , gt = []
          , wt = [];
        function bt(e, t) {
            var i, n, r, s, o, a, l, d, c = dt(e, Object.assign({}, ot, lt($e(t)))), u = !1, p = !1, f = !1, h = !1, m = [], v = Ve(Y, c.interactiveDebounce), g = vt++, w = (d = c.plugins).filter((function(e, t) {
                return d.indexOf(e) === t
            }
            )), b = {
                id: g,
                reference: e,
                popper: He(),
                popperInstance: null,
                props: c,
                state: {
                    isEnabled: !0,
                    isVisible: !1,
                    isDestroyed: !1,
                    isMounted: !1,
                    isShown: !1
                },
                plugins: w,
                clearDelayTimeouts: function() {
                    clearTimeout(i),
                    clearTimeout(n),
                    cancelAnimationFrame(r)
                },
                setProps: function(t) {
                    0;
                    if (b.state.isDestroyed)
                        return;
                    I("onBeforeUpdate", [b, t]),
                    F();
                    var i = b.props
                      , n = dt(e, Object.assign({}, i, $e(t), {
                        ignoreAttributes: !0
                    }));
                    b.props = n,
                    R(),
                    i.interactiveDebounce !== n.interactiveDebounce && (N(),
                    v = Ve(Y, n.interactiveDebounce));
                    i.triggerTarget && !n.triggerTarget ? We(i.triggerTarget).forEach((function(e) {
                        e.removeAttribute("aria-expanded")
                    }
                    )) : n.triggerTarget && e.removeAttribute("aria-expanded");
                    z(),
                    _(),
                    E && E(i, n);
                    b.popperInstance && (J(),
                    Z().forEach((function(e) {
                        requestAnimationFrame(e._tippy.popperInstance.forceUpdate)
                    }
                    )));
                    I("onAfterUpdate", [b, t])
                },
                setContent: function(e) {
                    b.setProps({
                        content: e
                    })
                },
                show: function() {
                    0;
                    var e = b.state.isVisible
                      , t = b.state.isDestroyed
                      , i = !b.state.isEnabled
                      , n = Ze.isTouch && !b.props.touch
                      , r = De(b.props.duration, 0, ot.duration);
                    if (e || t || i || n)
                        return;
                    if (M().hasAttribute("disabled"))
                        return;
                    if (I("onShow", [b], !1),
                    !1 === b.props.onShow(b))
                        return;
                    b.state.isVisible = !0,
                    A() && (x.style.visibility = "visible");
                    _(),
                    G(),
                    b.state.isMounted || (x.style.transition = "none");
                    if (A()) {
                        var s = k();
                        Xe([s.box, s.content], 0)
                    }
                    a = function() {
                        var e;
                        if (b.state.isVisible && !h) {
                            if (h = !0,
                            x.offsetHeight,
                            x.style.transition = b.props.moveTransition,
                            A() && b.props.animation) {
                                var t = k()
                                  , i = t.box
                                  , n = t.content;
                                Xe([i, n], r),
                                Ue([i, n], "visible")
                            }
                            D(),
                            z(),
                            je(wt, b),
                            null == (e = b.popperInstance) || e.forceUpdate(),
                            I("onMount", [b]),
                            b.props.animation && A() && function(e, t) {
                                $(e, t)
                            }(r, (function() {
                                b.state.isShown = !0,
                                I("onShown", [b])
                            }
                            ))
                        }
                    }
                    ,
                    function() {
                        var e, t = b.props.appendTo, i = M();
                        e = b.props.interactive && t === Ie || "parent" === t ? i.parentNode : Ne(t, [i]);
                        e.contains(x) || e.appendChild(x);
                        b.state.isMounted = !0,
                        J(),
                        !1
                    }()
                },
                hide: function() {
                    0;
                    var e = !b.state.isVisible
                      , t = b.state.isDestroyed
                      , i = !b.state.isEnabled
                      , n = De(b.props.duration, 1, ot.duration);
                    if (e || t || i)
                        return;
                    if (I("onHide", [b], !1),
                    !1 === b.props.onHide(b))
                        return;
                    b.state.isVisible = !1,
                    b.state.isShown = !1,
                    h = !1,
                    u = !1,
                    A() && (x.style.visibility = "hidden");
                    if (N(),
                    B(),
                    _(!0),
                    A()) {
                        var r = k()
                          , s = r.box
                          , o = r.content;
                        b.props.animation && (Xe([s, o], n),
                        Ue([s, o], "hidden"))
                    }
                    D(),
                    z(),
                    b.props.animation ? A() && function(e, t) {
                        $(e, (function() {
                            !b.state.isVisible && x.parentNode && x.parentNode.contains(x) && t()
                        }
                        ))
                    }(n, b.unmount) : b.unmount()
                },
                hideWithInteractivity: function(e) {
                    0;
                    O().addEventListener("mousemove", v),
                    je(gt, v),
                    v(e)
                },
                enable: function() {
                    b.state.isEnabled = !0
                },
                disable: function() {
                    b.hide(),
                    b.state.isEnabled = !1
                },
                unmount: function() {
                    0;
                    b.state.isVisible && b.hide();
                    if (!b.state.isMounted)
                        return;
                    Q(),
                    Z().forEach((function(e) {
                        e._tippy.unmount()
                    }
                    )),
                    x.parentNode && x.parentNode.removeChild(x);
                    wt = wt.filter((function(e) {
                        return e !== b
                    }
                    )),
                    b.state.isMounted = !1,
                    I("onHidden", [b])
                },
                destroy: function() {
                    0;
                    if (b.state.isDestroyed)
                        return;
                    b.clearDelayTimeouts(),
                    b.unmount(),
                    F(),
                    delete e._tippy,
                    b.state.isDestroyed = !0,
                    I("onDestroy", [b])
                }
            };
            if (!c.render)
                return b;
            var y = c.render(b)
              , x = y.popper
              , E = y.onUpdate;
            x.setAttribute("data-tippy-root", ""),
            x.id = "tippy-" + b.id,
            b.popper = x,
            e._tippy = b,
            x._tippy = b;
            var S = w.map((function(e) {
                return e.fn(b)
            }
            ))
              , T = e.hasAttribute("aria-expanded");
            return R(),
            z(),
            _(),
            I("onCreate", [b]),
            c.showOnCreate && ee(),
            x.addEventListener("mouseenter", (function() {
                b.props.interactive && b.state.isVisible && b.clearDelayTimeouts()
            }
            )),
            x.addEventListener("mouseleave", (function() {
                b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && O().addEventListener("mousemove", v)
            }
            )),
            b;
            function L() {
                var e = b.props.touch;
                return Array.isArray(e) ? e : [e, 0]
            }
            function C() {
                return "hold" === L()[0]
            }
            function A() {
                var e;
                return !(null == (e = b.props.render) || !e.$$tippy)
            }
            function M() {
                return l || e
            }
            function O() {
                var e = M().parentNode;
                return e ? Ke(e) : document
            }
            function k() {
                return ht(x)
            }
            function P(e) {
                return b.state.isMounted && !b.state.isVisible || Ze.isTouch || s && "focus" === s.type ? 0 : De(b.props.delay, e ? 0 : 1, ot.delay)
            }
            function _(e) {
                void 0 === e && (e = !1),
                x.style.pointerEvents = b.props.interactive && !e ? "" : "none",
                x.style.zIndex = "" + b.props.zIndex
            }
            function I(e, t, i) {
                var n;
                (void 0 === i && (i = !0),
                S.forEach((function(i) {
                    i[e] && i[e].apply(i, t)
                }
                )),
                i) && (n = b.props)[e].apply(n, t)
            }
            function D() {
                var t = b.props.aria;
                if (t.content) {
                    var i = "aria-" + t.content
                      , n = x.id;
                    We(b.props.triggerTarget || e).forEach((function(e) {
                        var t = e.getAttribute(i);
                        if (b.state.isVisible)
                            e.setAttribute(i, t ? t + " " + n : n);
                        else {
                            var r = t && t.replace(n, "").trim();
                            r ? e.setAttribute(i, r) : e.removeAttribute(i)
                        }
                    }
                    ))
                }
            }
            function z() {
                !T && b.props.aria.expanded && We(b.props.triggerTarget || e).forEach((function(e) {
                    b.props.interactive ? e.setAttribute("aria-expanded", b.state.isVisible && e === M() ? "true" : "false") : e.removeAttribute("aria-expanded")
                }
                ))
            }
            function N() {
                O().removeEventListener("mousemove", v),
                gt = gt.filter((function(e) {
                    return e !== v
                }
                ))
            }
            function V(t) {
                if (!Ze.isTouch || !f && "mousedown" !== t.type) {
                    var i = t.composedPath && t.composedPath()[0] || t.target;
                    if (!b.props.interactive || !Qe(x, i)) {
                        if (We(b.props.triggerTarget || e).some((function(e) {
                            return Qe(e, i)
                        }
                        ))) {
                            if (Ze.isTouch)
                                return;
                            if (b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
                                return
                        } else
                            I("onClickOutside", [b, t]);
                        !0 === b.props.hideOnClick && (b.clearDelayTimeouts(),
                        b.hide(),
                        p = !0,
                        setTimeout((function() {
                            p = !1
                        }
                        )),
                        b.state.isMounted || B())
                    }
                }
            }
            function W() {
                f = !0
            }
            function j() {
                f = !1
            }
            function G() {
                var e = O();
                e.addEventListener("mousedown", V, !0),
                e.addEventListener("touchend", V, _e),
                e.addEventListener("touchstart", j, _e),
                e.addEventListener("touchmove", W, _e)
            }
            function B() {
                var e = O();
                e.removeEventListener("mousedown", V, !0),
                e.removeEventListener("touchend", V, _e),
                e.removeEventListener("touchstart", j, _e),
                e.removeEventListener("touchmove", W, _e)
            }
            function $(e, t) {
                var i = k().box;
                function n(e) {
                    e.target === i && (Je(i, "remove", n),
                    t())
                }
                if (0 === e)
                    return t();
                Je(i, "remove", o),
                Je(i, "add", n),
                o = n
            }
            function H(t, i, n) {
                void 0 === n && (n = !1),
                We(b.props.triggerTarget || e).forEach((function(e) {
                    e.addEventListener(t, i, n),
                    m.push({
                        node: e,
                        eventType: t,
                        handler: i,
                        options: n
                    })
                }
                ))
            }
            function R() {
                var e;
                C() && (H("touchstart", q, {
                    passive: !0
                }),
                H("touchend", X, {
                    passive: !0
                })),
                (e = b.props.trigger,
                e.split(/\s+/).filter(Boolean)).forEach((function(e) {
                    if ("manual" !== e)
                        switch (H(e, q),
                        e) {
                        case "mouseenter":
                            H("mouseleave", X);
                            break;
                        case "focus":
                            H(rt ? "focusout" : "blur", U);
                            break;
                        case "focusin":
                            H("focusout", U)
                        }
                }
                ))
            }
            function F() {
                m.forEach((function(e) {
                    var t = e.node
                      , i = e.eventType
                      , n = e.handler
                      , r = e.options;
                    t.removeEventListener(i, n, r)
                }
                )),
                m = []
            }
            function q(e) {
                var t, i = !1;
                if (b.state.isEnabled && !K(e) && !p) {
                    var n = "focus" === (null == (t = s) ? void 0 : t.type);
                    s = e,
                    l = e.currentTarget,
                    z(),
                    !b.state.isVisible && Fe(e) && gt.forEach((function(t) {
                        return t(e)
                    }
                    )),
                    "click" === e.type && (b.props.trigger.indexOf("mouseenter") < 0 || u) && !1 !== b.props.hideOnClick && b.state.isVisible ? i = !0 : ee(e),
                    "click" === e.type && (u = !i),
                    i && !n && te(e)
                }
            }
            function Y(e) {
                var t = e.target
                  , i = M().contains(t) || x.contains(t);
                if ("mousemove" !== e.type || !i) {
                    var n = Z().concat(x).map((function(e) {
                        var t, i = null == (t = e._tippy.popperInstance) ? void 0 : t.state;
                        return i ? {
                            popperRect: e.getBoundingClientRect(),
                            popperState: i,
                            props: c
                        } : null
                    }
                    )).filter(Boolean);
                    (function(e, t) {
                        var i = t.clientX
                          , n = t.clientY;
                        return e.every((function(e) {
                            var t = e.popperRect
                              , r = e.popperState
                              , s = e.props.interactiveBorder
                              , o = Ge(r.placement)
                              , a = r.modifiersData.offset;
                            if (!a)
                                return !0;
                            var l = "bottom" === o ? a.top.y : 0
                              , d = "top" === o ? a.bottom.y : 0
                              , c = "right" === o ? a.left.x : 0
                              , u = "left" === o ? a.right.x : 0
                              , p = t.top - n + l > s
                              , f = n - t.bottom - d > s
                              , h = t.left - i + c > s
                              , m = i - t.right - u > s;
                            return p || f || h || m
                        }
                        ))
                    }
                    )(n, e) && (N(),
                    te(e))
                }
            }
            function X(e) {
                K(e) || b.props.trigger.indexOf("click") >= 0 && u || (b.props.interactive ? b.hideWithInteractivity(e) : te(e))
            }
            function U(e) {
                b.props.trigger.indexOf("focusin") < 0 && e.target !== M() || b.props.interactive && e.relatedTarget && x.contains(e.relatedTarget) || te(e)
            }
            function K(e) {
                return !!Ze.isTouch && C() !== e.type.indexOf("touch") >= 0
            }
            function J() {
                Q();
                var t = b.props
                  , i = t.popperOptions
                  , n = t.placement
                  , r = t.offset
                  , s = t.getReferenceClientRect
                  , o = t.moveTransition
                  , l = A() ? ht(x).arrow : null
                  , d = s ? {
                    getBoundingClientRect: s,
                    contextElement: s.contextElement || M()
                } : e
                  , c = {
                    name: "$$tippy",
                    enabled: !0,
                    phase: "beforeWrite",
                    requires: ["computeStyles"],
                    fn: function(e) {
                        var t = e.state;
                        if (A()) {
                            var i = k().box;
                            ["placement", "reference-hidden", "escaped"].forEach((function(e) {
                                "placement" === e ? i.setAttribute("data-placement", t.placement) : t.attributes.popper["data-popper-" + e] ? i.setAttribute("data-" + e, "") : i.removeAttribute("data-" + e)
                            }
                            )),
                            t.attributes.popper = {}
                        }
                    }
                }
                  , u = [{
                    name: "offset",
                    options: {
                        offset: r
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        padding: {
                            top: 2,
                            bottom: 2,
                            left: 5,
                            right: 5
                        }
                    }
                }, {
                    name: "flip",
                    options: {
                        padding: 5
                    }
                }, {
                    name: "computeStyles",
                    options: {
                        adaptive: !o
                    }
                }, c];
                A() && l && u.push({
                    name: "arrow",
                    options: {
                        element: l,
                        padding: 3
                    }
                }),
                u.push.apply(u, (null == i ? void 0 : i.modifiers) || []),
                b.popperInstance = Ae(d, x, Object.assign({}, i, {
                    placement: n,
                    onFirstUpdate: a,
                    modifiers: u
                }))
            }
            function Q() {
                b.popperInstance && (b.popperInstance.destroy(),
                b.popperInstance = null)
            }
            function Z() {
                return Be(x.querySelectorAll("[data-tippy-root]"))
            }
            function ee(e) {
                b.clearDelayTimeouts(),
                e && I("onTrigger", [b, e]),
                G();
                var t = P(!0)
                  , n = L()
                  , r = n[0]
                  , s = n[1];
                Ze.isTouch && "hold" === r && s && (t = s),
                t ? i = setTimeout((function() {
                    b.show()
                }
                ), t) : b.show()
            }
            function te(e) {
                if (b.clearDelayTimeouts(),
                I("onUntrigger", [b, e]),
                b.state.isVisible) {
                    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && u)) {
                        var t = P(!1);
                        t ? n = setTimeout((function() {
                            b.state.isVisible && b.hide()
                        }
                        ), t) : r = requestAnimationFrame((function() {
                            b.hide()
                        }
                        ))
                    }
                } else
                    B()
            }
        }
        function yt(e, t) {
            void 0 === t && (t = {});
            var i = ot.plugins.concat(t.plugins || []);
            document.addEventListener("touchstart", tt, _e),
            window.addEventListener("blur", nt);
            var n = Object.assign({}, t, {
                plugins: i
            })
              , r = Ye(e).reduce((function(e, t) {
                var i = t && bt(t, n);
                return i && e.push(i),
                e
            }
            ), []);
            return Re(e) ? r[0] : r
        }
        yt.defaultProps = ot,
        yt.setDefaultProps = function(e) {
            Object.keys(e).forEach((function(t) {
                ot[t] = e[t]
            }
            ))
        }
        ,
        yt.currentInput = Ze;
        Object.assign({}, de, {
            effect: function(e) {
                var t = e.state
                  , i = {
                    popper: {
                        position: t.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
                Object.assign(t.elements.popper.style, i.popper),
                t.styles = i,
                t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow)
            }
        });
        yt.setDefaultProps({
            render: mt
        });
        const xt = yt;
        function Et(e) {
            return null !== e && "object" == typeof e && "constructor"in e && e.constructor === Object
        }
        function St(e, t) {
            void 0 === e && (e = {}),
            void 0 === t && (t = {}),
            Object.keys(t).forEach((i=>{
                void 0 === e[i] ? e[i] = t[i] : Et(t[i]) && Et(e[i]) && Object.keys(t[i]).length > 0 && St(e[i], t[i])
            }
            ))
        }
        e.tippy = xt("[data-tippy-content]", {
            animation: "scale",
            trigger: "click",
            theme: "tomato"
        });
        const Tt = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector: ()=>null,
            querySelectorAll: ()=>[],
            getElementById: ()=>null,
            createEvent: ()=>({
                initEvent() {}
            }),
            createElement: ()=>({
                children: [],
                childNodes: [],
                style: {},
                setAttribute() {},
                getElementsByTagName: ()=>[]
            }),
            createElementNS: ()=>({}),
            importNode: ()=>null,
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function Lt() {
            const e = "undefined" != typeof document ? document : {};
            return St(e, Tt),
            e
        }
        const Ct = {
            document: Tt,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function() {
                return this
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle: ()=>({
                getPropertyValue: ()=>""
            }),
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia: ()=>({}),
            requestAnimationFrame: e=>"undefined" == typeof setTimeout ? (e(),
            null) : setTimeout(e, 0),
            cancelAnimationFrame(e) {
                "undefined" != typeof setTimeout && clearTimeout(e)
            }
        };
        function At() {
            const e = "undefined" != typeof window ? window : {};
            return St(e, Ct),
            e
        }
        function Mt(e, t) {
            return void 0 === t && (t = 0),
            setTimeout(e, t)
        }
        function Ot() {
            return Date.now()
        }
        function kt(e, t) {
            void 0 === t && (t = "x");
            const i = At();
            let n, r, s;
            const o = function(e) {
                const t = At();
                let i;
                return t.getComputedStyle && (i = t.getComputedStyle(e, null)),
                !i && e.currentStyle && (i = e.currentStyle),
                i || (i = e.style),
                i
            }(e);
            return i.WebKitCSSMatrix ? (r = o.transform || o.webkitTransform,
            r.split(",").length > 6 && (r = r.split(", ").map((e=>e.replace(",", "."))).join(", ")),
            s = new i.WebKitCSSMatrix("none" === r ? "" : r)) : (s = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
            n = s.toString().split(",")),
            "x" === t && (r = i.WebKitCSSMatrix ? s.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])),
            "y" === t && (r = i.WebKitCSSMatrix ? s.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])),
            r || 0
        }
        function Pt(e) {
            return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
        }
        function _t() {
            const e = Object(arguments.length <= 0 ? void 0 : arguments[0])
              , t = ["__proto__", "constructor", "prototype"];
            for (let n = 1; n < arguments.length; n += 1) {
                const r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
                if (null != r && (i = r,
                !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) {
                    const i = Object.keys(Object(r)).filter((e=>t.indexOf(e) < 0));
                    for (let t = 0, n = i.length; t < n; t += 1) {
                        const n = i[t]
                          , s = Object.getOwnPropertyDescriptor(r, n);
                        void 0 !== s && s.enumerable && (Pt(e[n]) && Pt(r[n]) ? r[n].__swiper__ ? e[n] = r[n] : _t(e[n], r[n]) : !Pt(e[n]) && Pt(r[n]) ? (e[n] = {},
                        r[n].__swiper__ ? e[n] = r[n] : _t(e[n], r[n])) : e[n] = r[n])
                    }
                }
            }
            var i;
            return e
        }
        function It(e, t, i) {
            e.style.setProperty(t, i)
        }
        function Dt(e) {
            let {swiper: t, targetPosition: i, side: n} = e;
            const r = At()
              , s = -t.translate;
            let o, a = null;
            const l = t.params.speed;
            t.wrapperEl.style.scrollSnapType = "none",
            r.cancelAnimationFrame(t.cssModeFrameID);
            const d = i > s ? "next" : "prev"
              , c = (e,t)=>"next" === d && e >= t || "prev" === d && e <= t
              , u = ()=>{
                o = (new Date).getTime(),
                null === a && (a = o);
                const e = Math.max(Math.min((o - a) / l, 1), 0)
                  , d = .5 - Math.cos(e * Math.PI) / 2;
                let p = s + d * (i - s);
                if (c(p, i) && (p = i),
                t.wrapperEl.scrollTo({
                    [n]: p
                }),
                c(p, i))
                    return t.wrapperEl.style.overflow = "hidden",
                    t.wrapperEl.style.scrollSnapType = "",
                    setTimeout((()=>{
                        t.wrapperEl.style.overflow = "",
                        t.wrapperEl.scrollTo({
                            [n]: p
                        })
                    }
                    )),
                    void r.cancelAnimationFrame(t.cssModeFrameID);
                t.cssModeFrameID = r.requestAnimationFrame(u)
            }
            ;
            u()
        }
        function zt(e, t) {
            return void 0 === t && (t = ""),
            [...e.children].filter((e=>e.matches(t)))
        }
        function Nt(e) {
            try {
                return void console.warn(e)
            } catch (e) {}
        }
        function Vt(e, t) {
            void 0 === t && (t = []);
            const i = document.createElement(e);
            return i.classList.add(...Array.isArray(t) ? t : function(e) {
                return void 0 === e && (e = ""),
                e.trim().split(" ").filter((e=>!!e.trim()))
            }(t)),
            i
        }
        function Wt(e, t) {
            return At().getComputedStyle(e, null).getPropertyValue(t)
        }
        function jt(e) {
            let t, i = e;
            if (i) {
                for (t = 0; null !== (i = i.previousSibling); )
                    1 === i.nodeType && (t += 1);
                return t
            }
        }
        function Gt(e, t, i) {
            const n = At();
            return i ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth
        }
        function Bt(e) {
            return (Array.isArray(e) ? e : [e]).filter((e=>!!e))
        }
        let $t, Ht, Rt;
        function Ft() {
            return $t || ($t = function() {
                const e = At()
                  , t = Lt();
                return {
                    smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior"in t.documentElement.style,
                    touch: !!("ontouchstart"in e || e.DocumentTouch && t instanceof e.DocumentTouch)
                }
            }()),
            $t
        }
        function qt(e) {
            return void 0 === e && (e = {}),
            Ht || (Ht = function(e) {
                let {userAgent: t} = void 0 === e ? {} : e;
                const i = Ft()
                  , n = At()
                  , r = n.navigator.platform
                  , s = t || n.navigator.userAgent
                  , o = {
                    ios: !1,
                    android: !1
                }
                  , a = n.screen.width
                  , l = n.screen.height
                  , d = s.match(/(Android);?[\s\/]+([\d.]+)?/);
                let c = s.match(/(iPad).*OS\s([\d_]+)/);
                const u = s.match(/(iPod)(.*OS\s([\d_]+))?/)
                  , p = !c && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
                  , f = "Win32" === r;
                let h = "MacIntel" === r;
                return !c && h && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${a}x${l}`) >= 0 && (c = s.match(/(Version)\/([\d.]+)/),
                c || (c = [0, 1, "13_0_0"]),
                h = !1),
                d && !f && (o.os = "android",
                o.android = !0),
                (c || p || u) && (o.os = "ios",
                o.ios = !0),
                o
            }(e)),
            Ht
        }
        function Yt() {
            return Rt || (Rt = function() {
                const e = At()
                  , t = qt();
                let i = !1;
                function n() {
                    const t = e.navigator.userAgent.toLowerCase();
                    return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
                }
                if (n()) {
                    const t = String(e.navigator.userAgent);
                    if (t.includes("Version/")) {
                        const [e,n] = t.split("Version/")[1].split(" ")[0].split(".").map((e=>Number(e)));
                        i = e < 16 || 16 === e && n < 2
                    }
                }
                const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
                  , s = n();
                return {
                    isSafari: i || s,
                    needPerspectiveFix: i,
                    need3dFix: s || r && t.ios,
                    isWebView: r
                }
            }()),
            Rt
        }
        var Xt = {
            on(e, t, i) {
                const n = this;
                if (!n.eventsListeners || n.destroyed)
                    return n;
                if ("function" != typeof t)
                    return n;
                const r = i ? "unshift" : "push";
                return e.split(" ").forEach((e=>{
                    n.eventsListeners[e] || (n.eventsListeners[e] = []),
                    n.eventsListeners[e][r](t)
                }
                )),
                n
            },
            once(e, t, i) {
                const n = this;
                if (!n.eventsListeners || n.destroyed)
                    return n;
                if ("function" != typeof t)
                    return n;
                function r() {
                    n.off(e, r),
                    r.__emitterProxy && delete r.__emitterProxy;
                    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
                        s[o] = arguments[o];
                    t.apply(n, s)
                }
                return r.__emitterProxy = t,
                n.on(e, r, i)
            },
            onAny(e, t) {
                const i = this;
                if (!i.eventsListeners || i.destroyed)
                    return i;
                if ("function" != typeof e)
                    return i;
                const n = t ? "unshift" : "push";
                return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[n](e),
                i
            },
            offAny(e) {
                const t = this;
                if (!t.eventsListeners || t.destroyed)
                    return t;
                if (!t.eventsAnyListeners)
                    return t;
                const i = t.eventsAnyListeners.indexOf(e);
                return i >= 0 && t.eventsAnyListeners.splice(i, 1),
                t
            },
            off(e, t) {
                const i = this;
                return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach((e=>{
                    void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach(((n,r)=>{
                        (n === t || n.__emitterProxy && n.__emitterProxy === t) && i.eventsListeners[e].splice(r, 1)
                    }
                    ))
                }
                )),
                i) : i
            },
            emit() {
                const e = this;
                if (!e.eventsListeners || e.destroyed)
                    return e;
                if (!e.eventsListeners)
                    return e;
                let t, i, n;
                for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
                    s[o] = arguments[o];
                "string" == typeof s[0] || Array.isArray(s[0]) ? (t = s[0],
                i = s.slice(1, s.length),
                n = e) : (t = s[0].events,
                i = s[0].data,
                n = s[0].context || e),
                i.unshift(n);
                return (Array.isArray(t) ? t : t.split(" ")).forEach((t=>{
                    e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e=>{
                        e.apply(n, [t, ...i])
                    }
                    )),
                    e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e=>{
                        e.apply(n, i)
                    }
                    ))
                }
                )),
                e
            }
        };
        const Ut = (e,t,i)=>{
            t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
        }
        ;
        const Kt = (e,t)=>{
            if (!e || e.destroyed || !e.params)
                return;
            const i = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
            if (i) {
                let t = i.querySelector(`.${e.params.lazyPreloaderClass}`);
                !t && e.isElement && (i.shadowRoot ? t = i.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame((()=>{
                    i.shadowRoot && (t = i.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`),
                    t && t.remove())
                }
                ))),
                t && t.remove()
            }
        }
          , Jt = (e,t)=>{
            if (!e.slides[t])
                return;
            const i = e.slides[t].querySelector('[loading="lazy"]');
            i && i.removeAttribute("loading")
        }
          , Qt = e=>{
            if (!e || e.destroyed || !e.params)
                return;
            let t = e.params.lazyPreloadPrevNext;
            const i = e.slides.length;
            if (!i || !t || t < 0)
                return;
            t = Math.min(t, i);
            const n = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView)
              , r = e.activeIndex;
            if (e.params.grid && e.params.grid.rows > 1) {
                const i = r
                  , s = [i - t];
                return s.push(...Array.from({
                    length: t
                }).map(((e,t)=>i + n + t))),
                void e.slides.forEach(((t,i)=>{
                    s.includes(t.column) && Jt(e, i)
                }
                ))
            }
            const s = r + n - 1;
            if (e.params.rewind || e.params.loop)
                for (let n = r - t; n <= s + t; n += 1) {
                    const t = (n % i + i) % i;
                    (t < r || t > s) && Jt(e, t)
                }
            else
                for (let n = Math.max(r - t, 0); n <= Math.min(s + t, i - 1); n += 1)
                    n !== r && (n > s || n < r) && Jt(e, n)
        }
        ;
        var Zt = {
            updateSize: function() {
                const e = this;
                let t, i;
                const n = e.el;
                t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : n.clientWidth,
                i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : n.clientHeight,
                0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(Wt(n, "padding-left") || 0, 10) - parseInt(Wt(n, "padding-right") || 0, 10),
                i = i - parseInt(Wt(n, "padding-top") || 0, 10) - parseInt(Wt(n, "padding-bottom") || 0, 10),
                Number.isNaN(t) && (t = 0),
                Number.isNaN(i) && (i = 0),
                Object.assign(e, {
                    width: t,
                    height: i,
                    size: e.isHorizontal() ? t : i
                }))
            },
            updateSlides: function() {
                const e = this;
                function t(t, i) {
                    return parseFloat(t.getPropertyValue(e.getDirectionLabel(i)) || 0)
                }
                const i = e.params
                  , {wrapperEl: n, slidesEl: r, size: s, rtlTranslate: o, wrongRTL: a} = e
                  , l = e.virtual && i.virtual.enabled
                  , d = l ? e.virtual.slides.length : e.slides.length
                  , c = zt(r, `.${e.params.slideClass}, swiper-slide`)
                  , u = l ? e.virtual.slides.length : c.length;
                let p = [];
                const f = []
                  , h = [];
                let m = i.slidesOffsetBefore;
                "function" == typeof m && (m = i.slidesOffsetBefore.call(e));
                let v = i.slidesOffsetAfter;
                "function" == typeof v && (v = i.slidesOffsetAfter.call(e));
                const g = e.snapGrid.length
                  , w = e.slidesGrid.length;
                let b = i.spaceBetween
                  , y = -m
                  , x = 0
                  , E = 0;
                if (void 0 === s)
                    return;
                "string" == typeof b && b.indexOf("%") >= 0 ? b = parseFloat(b.replace("%", "")) / 100 * s : "string" == typeof b && (b = parseFloat(b)),
                e.virtualSize = -b,
                c.forEach((e=>{
                    o ? e.style.marginLeft = "" : e.style.marginRight = "",
                    e.style.marginBottom = "",
                    e.style.marginTop = ""
                }
                )),
                i.centeredSlides && i.cssMode && (It(n, "--swiper-centered-offset-before", ""),
                It(n, "--swiper-centered-offset-after", ""));
                const S = i.grid && i.grid.rows > 1 && e.grid;
                let T;
                S ? e.grid.initSlides(c) : e.grid && e.grid.unsetSlides();
                const L = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e=>void 0 !== i.breakpoints[e].slidesPerView)).length > 0;
                for (let n = 0; n < u; n += 1) {
                    let r;
                    if (T = 0,
                    c[n] && (r = c[n]),
                    S && e.grid.updateSlide(n, r, c),
                    !c[n] || "none" !== Wt(r, "display")) {
                        if ("auto" === i.slidesPerView) {
                            L && (c[n].style[e.getDirectionLabel("width")] = "");
                            const s = getComputedStyle(r)
                              , o = r.style.transform
                              , a = r.style.webkitTransform;
                            if (o && (r.style.transform = "none"),
                            a && (r.style.webkitTransform = "none"),
                            i.roundLengths)
                                T = e.isHorizontal() ? Gt(r, "width", !0) : Gt(r, "height", !0);
                            else {
                                const e = t(s, "width")
                                  , i = t(s, "padding-left")
                                  , n = t(s, "padding-right")
                                  , o = t(s, "margin-left")
                                  , a = t(s, "margin-right")
                                  , l = s.getPropertyValue("box-sizing");
                                if (l && "border-box" === l)
                                    T = e + o + a;
                                else {
                                    const {clientWidth: t, offsetWidth: s} = r;
                                    T = e + i + n + o + a + (s - t)
                                }
                            }
                            o && (r.style.transform = o),
                            a && (r.style.webkitTransform = a),
                            i.roundLengths && (T = Math.floor(T))
                        } else
                            T = (s - (i.slidesPerView - 1) * b) / i.slidesPerView,
                            i.roundLengths && (T = Math.floor(T)),
                            c[n] && (c[n].style[e.getDirectionLabel("width")] = `${T}px`);
                        c[n] && (c[n].swiperSlideSize = T),
                        h.push(T),
                        i.centeredSlides ? (y = y + T / 2 + x / 2 + b,
                        0 === x && 0 !== n && (y = y - s / 2 - b),
                        0 === n && (y = y - s / 2 - b),
                        Math.abs(y) < .001 && (y = 0),
                        i.roundLengths && (y = Math.floor(y)),
                        E % i.slidesPerGroup == 0 && p.push(y),
                        f.push(y)) : (i.roundLengths && (y = Math.floor(y)),
                        (E - Math.min(e.params.slidesPerGroupSkip, E)) % e.params.slidesPerGroup == 0 && p.push(y),
                        f.push(y),
                        y = y + T + b),
                        e.virtualSize += T + b,
                        x = T,
                        E += 1
                    }
                }
                if (e.virtualSize = Math.max(e.virtualSize, s) + v,
                o && a && ("slide" === i.effect || "coverflow" === i.effect) && (n.style.width = `${e.virtualSize + b}px`),
                i.setWrapperSize && (n.style[e.getDirectionLabel("width")] = `${e.virtualSize + b}px`),
                S && e.grid.updateWrapperSize(T, p),
                !i.centeredSlides) {
                    const t = [];
                    for (let n = 0; n < p.length; n += 1) {
                        let r = p[n];
                        i.roundLengths && (r = Math.floor(r)),
                        p[n] <= e.virtualSize - s && t.push(r)
                    }
                    p = t,
                    Math.floor(e.virtualSize - s) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - s)
                }
                if (l && i.loop) {
                    const t = h[0] + b;
                    if (i.slidesPerGroup > 1) {
                        const n = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup)
                          , r = t * i.slidesPerGroup;
                        for (let e = 0; e < n; e += 1)
                            p.push(p[p.length - 1] + r)
                    }
                    for (let n = 0; n < e.virtual.slidesBefore + e.virtual.slidesAfter; n += 1)
                        1 === i.slidesPerGroup && p.push(p[p.length - 1] + t),
                        f.push(f[f.length - 1] + t),
                        e.virtualSize += t
                }
                if (0 === p.length && (p = [0]),
                0 !== b) {
                    const t = e.isHorizontal() && o ? "marginLeft" : e.getDirectionLabel("marginRight");
                    c.filter(((e,t)=>!(i.cssMode && !i.loop) || t !== c.length - 1)).forEach((e=>{
                        e.style[t] = `${b}px`
                    }
                    ))
                }
                if (i.centeredSlides && i.centeredSlidesBounds) {
                    let e = 0;
                    h.forEach((t=>{
                        e += t + (b || 0)
                    }
                    )),
                    e -= b;
                    const t = e - s;
                    p = p.map((e=>e <= 0 ? -m : e > t ? t + v : e))
                }
                if (i.centerInsufficientSlides) {
                    let e = 0;
                    if (h.forEach((t=>{
                        e += t + (b || 0)
                    }
                    )),
                    e -= b,
                    e < s) {
                        const t = (s - e) / 2;
                        p.forEach(((e,i)=>{
                            p[i] = e - t
                        }
                        )),
                        f.forEach(((e,i)=>{
                            f[i] = e + t
                        }
                        ))
                    }
                }
                if (Object.assign(e, {
                    slides: c,
                    snapGrid: p,
                    slidesGrid: f,
                    slidesSizesGrid: h
                }),
                i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
                    It(n, "--swiper-centered-offset-before", -p[0] + "px"),
                    It(n, "--swiper-centered-offset-after", e.size / 2 - h[h.length - 1] / 2 + "px");
                    const t = -e.snapGrid[0]
                      , i = -e.slidesGrid[0];
                    e.snapGrid = e.snapGrid.map((e=>e + t)),
                    e.slidesGrid = e.slidesGrid.map((e=>e + i))
                }
                if (u !== d && e.emit("slidesLengthChange"),
                p.length !== g && (e.params.watchOverflow && e.checkOverflow(),
                e.emit("snapGridLengthChange")),
                f.length !== w && e.emit("slidesGridLengthChange"),
                i.watchSlidesProgress && e.updateSlidesOffset(),
                e.emit("slidesUpdated"),
                !(l || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) {
                    const t = `${i.containerModifierClass}backface-hidden`
                      , n = e.el.classList.contains(t);
                    u <= i.maxBackfaceHiddenSlides ? n || e.el.classList.add(t) : n && e.el.classList.remove(t)
                }
            },
            updateAutoHeight: function(e) {
                const t = this
                  , i = []
                  , n = t.virtual && t.params.virtual.enabled;
                let r, s = 0;
                "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
                const o = e=>n ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
                if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                    if (t.params.centeredSlides)
                        (t.visibleSlides || []).forEach((e=>{
                            i.push(e)
                        }
                        ));
                    else
                        for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) {
                            const e = t.activeIndex + r;
                            if (e > t.slides.length && !n)
                                break;
                            i.push(o(e))
                        }
                else
                    i.push(o(t.activeIndex));
                for (r = 0; r < i.length; r += 1)
                    if (void 0 !== i[r]) {
                        const e = i[r].offsetHeight;
                        s = e > s ? e : s
                    }
                (s || 0 === s) && (t.wrapperEl.style.height = `${s}px`)
            },
            updateSlidesOffset: function() {
                const e = this
                  , t = e.slides
                  , i = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
                for (let n = 0; n < t.length; n += 1)
                    t[n].swiperSlideOffset = (e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop) - i - e.cssOverflowAdjustment()
            },
            updateSlidesProgress: function(e) {
                void 0 === e && (e = this && this.translate || 0);
                const t = this
                  , i = t.params
                  , {slides: n, rtlTranslate: r, snapGrid: s} = t;
                if (0 === n.length)
                    return;
                void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset();
                let o = -e;
                r && (o = e),
                n.forEach((e=>{
                    e.classList.remove(i.slideVisibleClass, i.slideFullyVisibleClass)
                }
                )),
                t.visibleSlidesIndexes = [],
                t.visibleSlides = [];
                let a = i.spaceBetween;
                "string" == typeof a && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * t.size : "string" == typeof a && (a = parseFloat(a));
                for (let e = 0; e < n.length; e += 1) {
                    const l = n[e];
                    let d = l.swiperSlideOffset;
                    i.cssMode && i.centeredSlides && (d -= n[0].swiperSlideOffset);
                    const c = (o + (i.centeredSlides ? t.minTranslate() : 0) - d) / (l.swiperSlideSize + a)
                      , u = (o - s[0] + (i.centeredSlides ? t.minTranslate() : 0) - d) / (l.swiperSlideSize + a)
                      , p = -(o - d)
                      , f = p + t.slidesSizesGrid[e]
                      , h = p >= 0 && p <= t.size - t.slidesSizesGrid[e];
                    (p >= 0 && p < t.size - 1 || f > 1 && f <= t.size || p <= 0 && f >= t.size) && (t.visibleSlides.push(l),
                    t.visibleSlidesIndexes.push(e),
                    n[e].classList.add(i.slideVisibleClass)),
                    h && n[e].classList.add(i.slideFullyVisibleClass),
                    l.progress = r ? -c : c,
                    l.originalProgress = r ? -u : u
                }
            },
            updateProgress: function(e) {
                const t = this;
                if (void 0 === e) {
                    const i = t.rtlTranslate ? -1 : 1;
                    e = t && t.translate && t.translate * i || 0
                }
                const i = t.params
                  , n = t.maxTranslate() - t.minTranslate();
                let {progress: r, isBeginning: s, isEnd: o, progressLoop: a} = t;
                const l = s
                  , d = o;
                if (0 === n)
                    r = 0,
                    s = !0,
                    o = !0;
                else {
                    r = (e - t.minTranslate()) / n;
                    const i = Math.abs(e - t.minTranslate()) < 1
                      , a = Math.abs(e - t.maxTranslate()) < 1;
                    s = i || r <= 0,
                    o = a || r >= 1,
                    i && (r = 0),
                    a && (r = 1)
                }
                if (i.loop) {
                    const i = t.getSlideIndexByData(0)
                      , n = t.getSlideIndexByData(t.slides.length - 1)
                      , r = t.slidesGrid[i]
                      , s = t.slidesGrid[n]
                      , o = t.slidesGrid[t.slidesGrid.length - 1]
                      , l = Math.abs(e);
                    a = l >= r ? (l - r) / o : (l + o - s) / o,
                    a > 1 && (a -= 1)
                }
                Object.assign(t, {
                    progress: r,
                    progressLoop: a,
                    isBeginning: s,
                    isEnd: o
                }),
                (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e),
                s && !l && t.emit("reachBeginning toEdge"),
                o && !d && t.emit("reachEnd toEdge"),
                (l && !s || d && !o) && t.emit("fromEdge"),
                t.emit("progress", r)
            },
            updateSlidesClasses: function() {
                const e = this
                  , {slides: t, params: i, slidesEl: n, activeIndex: r} = e
                  , s = e.virtual && i.virtual.enabled
                  , o = e.grid && i.grid && i.grid.rows > 1
                  , a = e=>zt(n, `.${i.slideClass}${e}, swiper-slide${e}`)[0];
                let l, d, c;
                if (s)
                    if (i.loop) {
                        let t = r - e.virtual.slidesBefore;
                        t < 0 && (t = e.virtual.slides.length + t),
                        t >= e.virtual.slides.length && (t -= e.virtual.slides.length),
                        l = a(`[data-swiper-slide-index="${t}"]`)
                    } else
                        l = a(`[data-swiper-slide-index="${r}"]`);
                else
                    o ? (l = t.filter((e=>e.column === r))[0],
                    c = t.filter((e=>e.column === r + 1))[0],
                    d = t.filter((e=>e.column === r - 1))[0]) : l = t[r];
                l && (o || (c = function(e, t) {
                    const i = [];
                    for (; e.nextElementSibling; ) {
                        const n = e.nextElementSibling;
                        t ? n.matches(t) && i.push(n) : i.push(n),
                        e = n
                    }
                    return i
                }(l, `.${i.slideClass}, swiper-slide`)[0],
                i.loop && !c && (c = t[0]),
                d = function(e, t) {
                    const i = [];
                    for (; e.previousElementSibling; ) {
                        const n = e.previousElementSibling;
                        t ? n.matches(t) && i.push(n) : i.push(n),
                        e = n
                    }
                    return i
                }(l, `.${i.slideClass}, swiper-slide`)[0],
                i.loop && 0 === !d && (d = t[t.length - 1]))),
                t.forEach((e=>{
                    Ut(e, e === l, i.slideActiveClass),
                    Ut(e, e === c, i.slideNextClass),
                    Ut(e, e === d, i.slidePrevClass)
                }
                )),
                e.emitSlidesClasses()
            },
            updateActiveIndex: function(e) {
                const t = this
                  , i = t.rtlTranslate ? t.translate : -t.translate
                  , {snapGrid: n, params: r, activeIndex: s, realIndex: o, snapIndex: a} = t;
                let l, d = e;
                const c = e=>{
                    let i = e - t.virtual.slidesBefore;
                    return i < 0 && (i = t.virtual.slides.length + i),
                    i >= t.virtual.slides.length && (i -= t.virtual.slides.length),
                    i
                }
                ;
                if (void 0 === d && (d = function(e) {
                    const {slidesGrid: t, params: i} = e
                      , n = e.rtlTranslate ? e.translate : -e.translate;
                    let r;
                    for (let e = 0; e < t.length; e += 1)
                        void 0 !== t[e + 1] ? n >= t[e] && n < t[e + 1] - (t[e + 1] - t[e]) / 2 ? r = e : n >= t[e] && n < t[e + 1] && (r = e + 1) : n >= t[e] && (r = e);
                    return i.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0),
                    r
                }(t)),
                n.indexOf(i) >= 0)
                    l = n.indexOf(i);
                else {
                    const e = Math.min(r.slidesPerGroupSkip, d);
                    l = e + Math.floor((d - e) / r.slidesPerGroup)
                }
                if (l >= n.length && (l = n.length - 1),
                d === s && !t.params.loop)
                    return void (l !== a && (t.snapIndex = l,
                    t.emit("snapIndexChange")));
                if (d === s && t.params.loop && t.virtual && t.params.virtual.enabled)
                    return void (t.realIndex = c(d));
                const u = t.grid && r.grid && r.grid.rows > 1;
                let p;
                if (t.virtual && r.virtual.enabled && r.loop)
                    p = c(d);
                else if (u) {
                    const e = t.slides.filter((e=>e.column === d))[0];
                    let i = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
                    Number.isNaN(i) && (i = Math.max(t.slides.indexOf(e), 0)),
                    p = Math.floor(i / r.grid.rows)
                } else if (t.slides[d]) {
                    const e = t.slides[d].getAttribute("data-swiper-slide-index");
                    p = e ? parseInt(e, 10) : d
                } else
                    p = d;
                Object.assign(t, {
                    previousSnapIndex: a,
                    snapIndex: l,
                    previousRealIndex: o,
                    realIndex: p,
                    previousIndex: s,
                    activeIndex: d
                }),
                t.initialized && Qt(t),
                t.emit("activeIndexChange"),
                t.emit("snapIndexChange"),
                (t.initialized || t.params.runCallbacksOnInit) && (o !== p && t.emit("realIndexChange"),
                t.emit("slideChange"))
            },
            updateClickedSlide: function(e, t) {
                const i = this
                  , n = i.params;
                let r = e.closest(`.${n.slideClass}, swiper-slide`);
                !r && i.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e=>{
                    !r && e.matches && e.matches(`.${n.slideClass}, swiper-slide`) && (r = e)
                }
                ));
                let s, o = !1;
                if (r)
                    for (let e = 0; e < i.slides.length; e += 1)
                        if (i.slides[e] === r) {
                            o = !0,
                            s = e;
                            break
                        }
                if (!r || !o)
                    return i.clickedSlide = void 0,
                    void (i.clickedIndex = void 0);
                i.clickedSlide = r,
                i.virtual && i.params.virtual.enabled ? i.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : i.clickedIndex = s,
                n.slideToClickedSlide && void 0 !== i.clickedIndex && i.clickedIndex !== i.activeIndex && i.slideToClickedSlide()
            }
        };
        var ei = {
            getTranslate: function(e) {
                void 0 === e && (e = this.isHorizontal() ? "x" : "y");
                const {params: t, rtlTranslate: i, translate: n, wrapperEl: r} = this;
                if (t.virtualTranslate)
                    return i ? -n : n;
                if (t.cssMode)
                    return n;
                let s = kt(r, e);
                return s += this.cssOverflowAdjustment(),
                i && (s = -s),
                s || 0
            },
            setTranslate: function(e, t) {
                const i = this
                  , {rtlTranslate: n, params: r, wrapperEl: s, progress: o} = i;
                let a, l = 0, d = 0;
                i.isHorizontal() ? l = n ? -e : e : d = e,
                r.roundLengths && (l = Math.floor(l),
                d = Math.floor(d)),
                i.previousTranslate = i.translate,
                i.translate = i.isHorizontal() ? l : d,
                r.cssMode ? s[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -d : r.virtualTranslate || (i.isHorizontal() ? l -= i.cssOverflowAdjustment() : d -= i.cssOverflowAdjustment(),
                s.style.transform = `translate3d(${l}px, ${d}px, 0px)`);
                const c = i.maxTranslate() - i.minTranslate();
                a = 0 === c ? 0 : (e - i.minTranslate()) / c,
                a !== o && i.updateProgress(e),
                i.emit("setTranslate", i.translate, t)
            },
            minTranslate: function() {
                return -this.snapGrid[0]
            },
            maxTranslate: function() {
                return -this.snapGrid[this.snapGrid.length - 1]
            },
            translateTo: function(e, t, i, n, r) {
                void 0 === e && (e = 0),
                void 0 === t && (t = this.params.speed),
                void 0 === i && (i = !0),
                void 0 === n && (n = !0);
                const s = this
                  , {params: o, wrapperEl: a} = s;
                if (s.animating && o.preventInteractionOnTransition)
                    return !1;
                const l = s.minTranslate()
                  , d = s.maxTranslate();
                let c;
                if (c = n && e > l ? l : n && e < d ? d : e,
                s.updateProgress(c),
                o.cssMode) {
                    const e = s.isHorizontal();
                    if (0 === t)
                        a[e ? "scrollLeft" : "scrollTop"] = -c;
                    else {
                        if (!s.support.smoothScroll)
                            return Dt({
                                swiper: s,
                                targetPosition: -c,
                                side: e ? "left" : "top"
                            }),
                            !0;
                        a.scrollTo({
                            [e ? "left" : "top"]: -c,
                            behavior: "smooth"
                        })
                    }
                    return !0
                }
                return 0 === t ? (s.setTransition(0),
                s.setTranslate(c),
                i && (s.emit("beforeTransitionStart", t, r),
                s.emit("transitionEnd"))) : (s.setTransition(t),
                s.setTranslate(c),
                i && (s.emit("beforeTransitionStart", t, r),
                s.emit("transitionStart")),
                s.animating || (s.animating = !0,
                s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(e) {
                    s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd),
                    s.onTranslateToWrapperTransitionEnd = null,
                    delete s.onTranslateToWrapperTransitionEnd,
                    s.animating = !1,
                    i && s.emit("transitionEnd"))
                }
                ),
                s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))),
                !0
            }
        };
        function ti(e) {
            let {swiper: t, runCallbacks: i, direction: n, step: r} = e;
            const {activeIndex: s, previousIndex: o} = t;
            let a = n;
            if (a || (a = s > o ? "next" : s < o ? "prev" : "reset"),
            t.emit(`transition${r}`),
            i && s !== o) {
                if ("reset" === a)
                    return void t.emit(`slideResetTransition${r}`);
                t.emit(`slideChangeTransition${r}`),
                "next" === a ? t.emit(`slideNextTransition${r}`) : t.emit(`slidePrevTransition${r}`)
            }
        }
        var ii = {
            slideTo: function(e, t, i, n, r) {
                void 0 === e && (e = 0),
                void 0 === i && (i = !0),
                "string" == typeof e && (e = parseInt(e, 10));
                const s = this;
                let o = e;
                o < 0 && (o = 0);
                const {params: a, snapGrid: l, slidesGrid: d, previousIndex: c, activeIndex: u, rtlTranslate: p, wrapperEl: f, enabled: h} = s;
                if (!h && !n && !r || s.destroyed || s.animating && a.preventInteractionOnTransition)
                    return !1;
                void 0 === t && (t = s.params.speed);
                const m = Math.min(s.params.slidesPerGroupSkip, o);
                let v = m + Math.floor((o - m) / s.params.slidesPerGroup);
                v >= l.length && (v = l.length - 1);
                const g = -l[v];
                if (a.normalizeSlideIndex)
                    for (let e = 0; e < d.length; e += 1) {
                        const t = -Math.floor(100 * g)
                          , i = Math.floor(100 * d[e])
                          , n = Math.floor(100 * d[e + 1]);
                        void 0 !== d[e + 1] ? t >= i && t < n - (n - i) / 2 ? o = e : t >= i && t < n && (o = e + 1) : t >= i && (o = e)
                    }
                if (s.initialized && o !== u) {
                    if (!s.allowSlideNext && (p ? g > s.translate && g > s.minTranslate() : g < s.translate && g < s.minTranslate()))
                        return !1;
                    if (!s.allowSlidePrev && g > s.translate && g > s.maxTranslate() && (u || 0) !== o)
                        return !1
                }
                let w;
                if (o !== (c || 0) && i && s.emit("beforeSlideChangeStart"),
                s.updateProgress(g),
                w = o > u ? "next" : o < u ? "prev" : "reset",
                p && -g === s.translate || !p && g === s.translate)
                    return s.updateActiveIndex(o),
                    a.autoHeight && s.updateAutoHeight(),
                    s.updateSlidesClasses(),
                    "slide" !== a.effect && s.setTranslate(g),
                    "reset" !== w && (s.transitionStart(i, w),
                    s.transitionEnd(i, w)),
                    !1;
                if (a.cssMode) {
                    const e = s.isHorizontal()
                      , i = p ? g : -g;
                    if (0 === t) {
                        const t = s.virtual && s.params.virtual.enabled;
                        t && (s.wrapperEl.style.scrollSnapType = "none",
                        s._immediateVirtual = !0),
                        t && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0,
                        requestAnimationFrame((()=>{
                            f[e ? "scrollLeft" : "scrollTop"] = i
                        }
                        ))) : f[e ? "scrollLeft" : "scrollTop"] = i,
                        t && requestAnimationFrame((()=>{
                            s.wrapperEl.style.scrollSnapType = "",
                            s._immediateVirtual = !1
                        }
                        ))
                    } else {
                        if (!s.support.smoothScroll)
                            return Dt({
                                swiper: s,
                                targetPosition: i,
                                side: e ? "left" : "top"
                            }),
                            !0;
                        f.scrollTo({
                            [e ? "left" : "top"]: i,
                            behavior: "smooth"
                        })
                    }
                    return !0
                }
                return s.setTransition(t),
                s.setTranslate(g),
                s.updateActiveIndex(o),
                s.updateSlidesClasses(),
                s.emit("beforeTransitionStart", t, n),
                s.transitionStart(i, w),
                0 === t ? s.transitionEnd(i, w) : s.animating || (s.animating = !0,
                s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function(e) {
                    s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd),
                    s.onSlideToWrapperTransitionEnd = null,
                    delete s.onSlideToWrapperTransitionEnd,
                    s.transitionEnd(i, w))
                }
                ),
                s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)),
                !0
            },
            slideToLoop: function(e, t, i, n) {
                if (void 0 === e && (e = 0),
                void 0 === i && (i = !0),
                "string" == typeof e) {
                    e = parseInt(e, 10)
                }
                const r = this;
                if (r.destroyed)
                    return;
                void 0 === t && (t = r.params.speed);
                const s = r.grid && r.params.grid && r.params.grid.rows > 1;
                let o = e;
                if (r.params.loop)
                    if (r.virtual && r.params.virtual.enabled)
                        o += r.virtual.slidesBefore;
                    else {
                        let e;
                        if (s) {
                            const t = o * r.params.grid.rows;
                            e = r.slides.filter((e=>1 * e.getAttribute("data-swiper-slide-index") === t))[0].column
                        } else
                            e = r.getSlideIndexByData(o);
                        const t = s ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length
                          , {centeredSlides: i} = r.params;
                        let a = r.params.slidesPerView;
                        "auto" === a ? a = r.slidesPerViewDynamic() : (a = Math.ceil(parseFloat(r.params.slidesPerView, 10)),
                        i && a % 2 == 0 && (a += 1));
                        let l = t - e < a;
                        if (i && (l = l || e < Math.ceil(a / 2)),
                        n && i && "auto" !== r.params.slidesPerView && !s && (l = !1),
                        l) {
                            const n = i ? e < r.activeIndex ? "prev" : "next" : e - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev";
                            r.loopFix({
                                direction: n,
                                slideTo: !0,
                                activeSlideIndex: "next" === n ? e + 1 : e - t + 1,
                                slideRealIndex: "next" === n ? r.realIndex : void 0
                            })
                        }
                        if (s) {
                            const e = o * r.params.grid.rows;
                            o = r.slides.filter((t=>1 * t.getAttribute("data-swiper-slide-index") === e))[0].column
                        } else
                            o = r.getSlideIndexByData(o)
                    }
                return requestAnimationFrame((()=>{
                    r.slideTo(o, t, i, n)
                }
                )),
                r
            },
            slideNext: function(e, t, i) {
                void 0 === t && (t = !0);
                const n = this
                  , {enabled: r, params: s, animating: o} = n;
                if (!r || n.destroyed)
                    return n;
                void 0 === e && (e = n.params.speed);
                let a = s.slidesPerGroup;
                "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (a = Math.max(n.slidesPerViewDynamic("current", !0), 1));
                const l = n.activeIndex < s.slidesPerGroupSkip ? 1 : a
                  , d = n.virtual && s.virtual.enabled;
                if (s.loop) {
                    if (o && !d && s.loopPreventsSliding)
                        return !1;
                    if (n.loopFix({
                        direction: "next"
                    }),
                    n._clientLeft = n.wrapperEl.clientLeft,
                    n.activeIndex === n.slides.length - 1 && s.cssMode)
                        return requestAnimationFrame((()=>{
                            n.slideTo(n.activeIndex + l, e, t, i)
                        }
                        )),
                        !0
                }
                return s.rewind && n.isEnd ? n.slideTo(0, e, t, i) : n.slideTo(n.activeIndex + l, e, t, i)
            },
            slidePrev: function(e, t, i) {
                void 0 === t && (t = !0);
                const n = this
                  , {params: r, snapGrid: s, slidesGrid: o, rtlTranslate: a, enabled: l, animating: d} = n;
                if (!l || n.destroyed)
                    return n;
                void 0 === e && (e = n.params.speed);
                const c = n.virtual && r.virtual.enabled;
                if (r.loop) {
                    if (d && !c && r.loopPreventsSliding)
                        return !1;
                    n.loopFix({
                        direction: "prev"
                    }),
                    n._clientLeft = n.wrapperEl.clientLeft
                }
                function u(e) {
                    return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
                }
                const p = u(a ? n.translate : -n.translate)
                  , f = s.map((e=>u(e)));
                let h = s[f.indexOf(p) - 1];
                if (void 0 === h && r.cssMode) {
                    let e;
                    s.forEach(((t,i)=>{
                        p >= t && (e = i)
                    }
                    )),
                    void 0 !== e && (h = s[e > 0 ? e - 1 : e])
                }
                let m = 0;
                if (void 0 !== h && (m = o.indexOf(h),
                m < 0 && (m = n.activeIndex - 1),
                "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (m = m - n.slidesPerViewDynamic("previous", !0) + 1,
                m = Math.max(m, 0))),
                r.rewind && n.isBeginning) {
                    const r = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1;
                    return n.slideTo(r, e, t, i)
                }
                return r.loop && 0 === n.activeIndex && r.cssMode ? (requestAnimationFrame((()=>{
                    n.slideTo(m, e, t, i)
                }
                )),
                !0) : n.slideTo(m, e, t, i)
            },
            slideReset: function(e, t, i) {
                void 0 === t && (t = !0);
                const n = this;
                if (!n.destroyed)
                    return void 0 === e && (e = n.params.speed),
                    n.slideTo(n.activeIndex, e, t, i)
            },
            slideToClosest: function(e, t, i, n) {
                void 0 === t && (t = !0),
                void 0 === n && (n = .5);
                const r = this;
                if (r.destroyed)
                    return;
                void 0 === e && (e = r.params.speed);
                let s = r.activeIndex;
                const o = Math.min(r.params.slidesPerGroupSkip, s)
                  , a = o + Math.floor((s - o) / r.params.slidesPerGroup)
                  , l = r.rtlTranslate ? r.translate : -r.translate;
                if (l >= r.snapGrid[a]) {
                    const e = r.snapGrid[a];
                    l - e > (r.snapGrid[a + 1] - e) * n && (s += r.params.slidesPerGroup)
                } else {
                    const e = r.snapGrid[a - 1];
                    l - e <= (r.snapGrid[a] - e) * n && (s -= r.params.slidesPerGroup)
                }
                return s = Math.max(s, 0),
                s = Math.min(s, r.slidesGrid.length - 1),
                r.slideTo(s, e, t, i)
            },
            slideToClickedSlide: function() {
                const e = this;
                if (e.destroyed)
                    return;
                const {params: t, slidesEl: i} = e
                  , n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
                let r, s = e.clickedIndex;
                const o = e.isElement ? "swiper-slide" : `.${t.slideClass}`;
                if (t.loop) {
                    if (e.animating)
                        return;
                    r = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
                    t.centeredSlides ? s < e.loopedSlides - n / 2 || s > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(),
                    s = e.getSlideIndex(zt(i, `${o}[data-swiper-slide-index="${r}"]`)[0]),
                    Mt((()=>{
                        e.slideTo(s)
                    }
                    ))) : e.slideTo(s) : s > e.slides.length - n ? (e.loopFix(),
                    s = e.getSlideIndex(zt(i, `${o}[data-swiper-slide-index="${r}"]`)[0]),
                    Mt((()=>{
                        e.slideTo(s)
                    }
                    ))) : e.slideTo(s)
                } else
                    e.slideTo(s)
            }
        };
        var ni = {
            loopCreate: function(e) {
                const t = this
                  , {params: i, slidesEl: n} = t;
                if (!i.loop || t.virtual && t.params.virtual.enabled)
                    return;
                const r = ()=>{
                    zt(n, `.${i.slideClass}, swiper-slide`).forEach(((e,t)=>{
                        e.setAttribute("data-swiper-slide-index", t)
                    }
                    ))
                }
                  , s = t.grid && i.grid && i.grid.rows > 1
                  , o = i.slidesPerGroup * (s ? i.grid.rows : 1)
                  , a = t.slides.length % o != 0
                  , l = s && t.slides.length % i.grid.rows != 0
                  , d = e=>{
                    for (let n = 0; n < e; n += 1) {
                        const e = t.isElement ? Vt("swiper-slide", [i.slideBlankClass]) : Vt("div", [i.slideClass, i.slideBlankClass]);
                        t.slidesEl.append(e)
                    }
                }
                ;
                if (a) {
                    if (i.loopAddBlankSlides) {
                        d(o - t.slides.length % o),
                        t.recalcSlides(),
                        t.updateSlides()
                    } else
                        Nt("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                    r()
                } else if (l) {
                    if (i.loopAddBlankSlides) {
                        d(i.grid.rows - t.slides.length % i.grid.rows),
                        t.recalcSlides(),
                        t.updateSlides()
                    } else
                        Nt("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                    r()
                } else
                    r();
                t.loopFix({
                    slideRealIndex: e,
                    direction: i.centeredSlides ? void 0 : "next"
                })
            },
            loopFix: function(e) {
                let {slideRealIndex: t, slideTo: i=!0, direction: n, setTranslate: r, activeSlideIndex: s, byController: o, byMousewheel: a} = void 0 === e ? {} : e;
                const l = this;
                if (!l.params.loop)
                    return;
                l.emit("beforeLoopFix");
                const {slides: d, allowSlidePrev: c, allowSlideNext: u, slidesEl: p, params: f} = l
                  , {centeredSlides: h} = f;
                if (l.allowSlidePrev = !0,
                l.allowSlideNext = !0,
                l.virtual && f.virtual.enabled)
                    return i && (f.centeredSlides || 0 !== l.snapIndex ? f.centeredSlides && l.snapIndex < f.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)),
                    l.allowSlidePrev = c,
                    l.allowSlideNext = u,
                    void l.emit("loopFix");
                let m = f.slidesPerView;
                "auto" === m ? m = l.slidesPerViewDynamic() : (m = Math.ceil(parseFloat(f.slidesPerView, 10)),
                h && m % 2 == 0 && (m += 1));
                const v = f.slidesPerGroupAuto ? m : f.slidesPerGroup;
                let g = v;
                g % v != 0 && (g += v - g % v),
                g += f.loopAdditionalSlides,
                l.loopedSlides = g;
                const w = l.grid && f.grid && f.grid.rows > 1;
                d.length < m + g ? Nt("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : w && "row" === f.grid.fill && Nt("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
                const b = []
                  , y = [];
                let x = l.activeIndex;
                void 0 === s ? s = l.getSlideIndex(d.filter((e=>e.classList.contains(f.slideActiveClass)))[0]) : x = s;
                const E = "next" === n || !n
                  , S = "prev" === n || !n;
                let T = 0
                  , L = 0;
                const C = w ? Math.ceil(d.length / f.grid.rows) : d.length
                  , A = (w ? d[s].column : s) + (h && void 0 === r ? -m / 2 + .5 : 0);
                if (A < g) {
                    T = Math.max(g - A, v);
                    for (let e = 0; e < g - A; e += 1) {
                        const t = e - Math.floor(e / C) * C;
                        if (w) {
                            const e = C - t - 1;
                            for (let t = d.length - 1; t >= 0; t -= 1)
                                d[t].column === e && b.push(t)
                        } else
                            b.push(C - t - 1)
                    }
                } else if (A + m > C - g) {
                    L = Math.max(A - (C - 2 * g), v);
                    for (let e = 0; e < L; e += 1) {
                        const t = e - Math.floor(e / C) * C;
                        w ? d.forEach(((e,i)=>{
                            e.column === t && y.push(i)
                        }
                        )) : y.push(t)
                    }
                }
                if (l.__preventObserver__ = !0,
                requestAnimationFrame((()=>{
                    l.__preventObserver__ = !1
                }
                )),
                S && b.forEach((e=>{
                    d[e].swiperLoopMoveDOM = !0,
                    p.prepend(d[e]),
                    d[e].swiperLoopMoveDOM = !1
                }
                )),
                E && y.forEach((e=>{
                    d[e].swiperLoopMoveDOM = !0,
                    p.append(d[e]),
                    d[e].swiperLoopMoveDOM = !1
                }
                )),
                l.recalcSlides(),
                "auto" === f.slidesPerView ? l.updateSlides() : w && (b.length > 0 && S || y.length > 0 && E) && l.slides.forEach(((e,t)=>{
                    l.grid.updateSlide(t, e, l.slides)
                }
                )),
                f.watchSlidesProgress && l.updateSlidesOffset(),
                i)
                    if (b.length > 0 && S) {
                        if (void 0 === t) {
                            const e = l.slidesGrid[x]
                              , t = l.slidesGrid[x + T] - e;
                            a ? l.setTranslate(l.translate - t) : (l.slideTo(x + Math.ceil(T), 0, !1, !0),
                            r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t,
                            l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                        } else if (r) {
                            const e = w ? b.length / f.grid.rows : b.length;
                            l.slideTo(l.activeIndex + e, 0, !1, !0),
                            l.touchEventsData.currentTranslate = l.translate
                        }
                    } else if (y.length > 0 && E)
                        if (void 0 === t) {
                            const e = l.slidesGrid[x]
                              , t = l.slidesGrid[x - L] - e;
                            a ? l.setTranslate(l.translate - t) : (l.slideTo(x - L, 0, !1, !0),
                            r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t,
                            l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                        } else {
                            const e = w ? y.length / f.grid.rows : y.length;
                            l.slideTo(l.activeIndex - e, 0, !1, !0)
                        }
                if (l.allowSlidePrev = c,
                l.allowSlideNext = u,
                l.controller && l.controller.control && !o) {
                    const e = {
                        slideRealIndex: t,
                        direction: n,
                        setTranslate: r,
                        activeSlideIndex: s,
                        byController: !0
                    };
                    Array.isArray(l.controller.control) ? l.controller.control.forEach((t=>{
                        !t.destroyed && t.params.loop && t.loopFix({
                            ...e,
                            slideTo: t.params.slidesPerView === f.slidesPerView && i
                        })
                    }
                    )) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({
                        ...e,
                        slideTo: l.controller.control.params.slidesPerView === f.slidesPerView && i
                    })
                }
                l.emit("loopFix")
            },
            loopDestroy: function() {
                const e = this
                  , {params: t, slidesEl: i} = e;
                if (!t.loop || e.virtual && e.params.virtual.enabled)
                    return;
                e.recalcSlides();
                const n = [];
                e.slides.forEach((e=>{
                    const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
                    n[t] = e
                }
                )),
                e.slides.forEach((e=>{
                    e.removeAttribute("data-swiper-slide-index")
                }
                )),
                n.forEach((e=>{
                    i.append(e)
                }
                )),
                e.recalcSlides(),
                e.slideTo(e.realIndex, 0)
            }
        };
        function ri(e, t, i) {
            const n = At()
              , {params: r} = e
              , s = r.edgeSwipeDetection
              , o = r.edgeSwipeThreshold;
            return !s || !(i <= o || i >= n.innerWidth - o) || "prevent" === s && (t.preventDefault(),
            !0)
        }
        function si(e) {
            const t = this
              , i = Lt();
            let n = e;
            n.originalEvent && (n = n.originalEvent);
            const r = t.touchEventsData;
            if ("pointerdown" === n.type) {
                if (null !== r.pointerId && r.pointerId !== n.pointerId)
                    return;
                r.pointerId = n.pointerId
            } else
                "touchstart" === n.type && 1 === n.targetTouches.length && (r.touchId = n.targetTouches[0].identifier);
            if ("touchstart" === n.type)
                return void ri(t, n, n.targetTouches[0].pageX);
            const {params: s, touches: o, enabled: a} = t;
            if (!a)
                return;
            if (!s.simulateTouch && "mouse" === n.pointerType)
                return;
            if (t.animating && s.preventInteractionOnTransition)
                return;
            !t.animating && s.cssMode && s.loop && t.loopFix();
            let l = n.target;
            if ("wrapper" === s.touchEventsTarget && !t.wrapperEl.contains(l))
                return;
            if ("which"in n && 3 === n.which)
                return;
            if ("button"in n && n.button > 0)
                return;
            if (r.isTouched && r.isMoved)
                return;
            const d = !!s.noSwipingClass && "" !== s.noSwipingClass
              , c = n.composedPath ? n.composedPath() : n.path;
            d && n.target && n.target.shadowRoot && c && (l = c[0]);
            const u = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`
              , p = !(!n.target || !n.target.shadowRoot);
            if (s.noSwiping && (p ? function(e, t) {
                return void 0 === t && (t = this),
                function t(i) {
                    if (!i || i === Lt() || i === At())
                        return null;
                    i.assignedSlot && (i = i.assignedSlot);
                    const n = i.closest(e);
                    return n || i.getRootNode ? n || t(i.getRootNode().host) : null
                }(t)
            }(u, l) : l.closest(u)))
                return void (t.allowClick = !0);
            if (s.swipeHandler && !l.closest(s.swipeHandler))
                return;
            o.currentX = n.pageX,
            o.currentY = n.pageY;
            const f = o.currentX
              , h = o.currentY;
            if (!ri(t, n, f))
                return;
            Object.assign(r, {
                isTouched: !0,
                isMoved: !1,
                allowTouchCallbacks: !0,
                isScrolling: void 0,
                startMoving: void 0
            }),
            o.startX = f,
            o.startY = h,
            r.touchStartTime = Ot(),
            t.allowClick = !0,
            t.updateSize(),
            t.swipeDirection = void 0,
            s.threshold > 0 && (r.allowThresholdMove = !1);
            let m = !0;
            l.matches(r.focusableElements) && (m = !1,
            "SELECT" === l.nodeName && (r.isTouched = !1)),
            i.activeElement && i.activeElement.matches(r.focusableElements) && i.activeElement !== l && i.activeElement.blur();
            const v = m && t.allowTouchMove && s.touchStartPreventDefault;
            !s.touchStartForcePreventDefault && !v || l.isContentEditable || n.preventDefault(),
            s.freeMode && s.freeMode.enabled && t.freeMode && t.animating && !s.cssMode && t.freeMode.onTouchStart(),
            t.emit("touchStart", n)
        }
        function oi(e) {
            const t = Lt()
              , i = this
              , n = i.touchEventsData
              , {params: r, touches: s, rtlTranslate: o, enabled: a} = i;
            if (!a)
                return;
            if (!r.simulateTouch && "mouse" === e.pointerType)
                return;
            let l, d = e;
            if (d.originalEvent && (d = d.originalEvent),
            "pointermove" === d.type) {
                if (null !== n.touchId)
                    return;
                if (d.pointerId !== n.pointerId)
                    return
            }
            if ("touchmove" === d.type) {
                if (l = [...d.changedTouches].filter((e=>e.identifier === n.touchId))[0],
                !l || l.identifier !== n.touchId)
                    return
            } else
                l = d;
            if (!n.isTouched)
                return void (n.startMoving && n.isScrolling && i.emit("touchMoveOpposite", d));
            const c = l.pageX
              , u = l.pageY;
            if (d.preventedByNestedSwiper)
                return s.startX = c,
                void (s.startY = u);
            if (!i.allowTouchMove)
                return d.target.matches(n.focusableElements) || (i.allowClick = !1),
                void (n.isTouched && (Object.assign(s, {
                    startX: c,
                    startY: u,
                    currentX: c,
                    currentY: u
                }),
                n.touchStartTime = Ot()));
            if (r.touchReleaseOnEdges && !r.loop)
                if (i.isVertical()) {
                    if (u < s.startY && i.translate <= i.maxTranslate() || u > s.startY && i.translate >= i.minTranslate())
                        return n.isTouched = !1,
                        void (n.isMoved = !1)
                } else if (c < s.startX && i.translate <= i.maxTranslate() || c > s.startX && i.translate >= i.minTranslate())
                    return;
            if (t.activeElement && d.target === t.activeElement && d.target.matches(n.focusableElements))
                return n.isMoved = !0,
                void (i.allowClick = !1);
            n.allowTouchCallbacks && i.emit("touchMove", d),
            s.previousX = s.currentX,
            s.previousY = s.currentY,
            s.currentX = c,
            s.currentY = u;
            const p = s.currentX - s.startX
              , f = s.currentY - s.startY;
            if (i.params.threshold && Math.sqrt(p ** 2 + f ** 2) < i.params.threshold)
                return;
            if (void 0 === n.isScrolling) {
                let e;
                i.isHorizontal() && s.currentY === s.startY || i.isVertical() && s.currentX === s.startX ? n.isScrolling = !1 : p * p + f * f >= 25 && (e = 180 * Math.atan2(Math.abs(f), Math.abs(p)) / Math.PI,
                n.isScrolling = i.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
            }
            if (n.isScrolling && i.emit("touchMoveOpposite", d),
            void 0 === n.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (n.startMoving = !0)),
            n.isScrolling || "touchmove" === d.type && n.preventTouchMoveFromPointerMove)
                return void (n.isTouched = !1);
            if (!n.startMoving)
                return;
            i.allowClick = !1,
            !r.cssMode && d.cancelable && d.preventDefault(),
            r.touchMoveStopPropagation && !r.nested && d.stopPropagation();
            let h = i.isHorizontal() ? p : f
              , m = i.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY;
            r.oneWayMovement && (h = Math.abs(h) * (o ? 1 : -1),
            m = Math.abs(m) * (o ? 1 : -1)),
            s.diff = h,
            h *= r.touchRatio,
            o && (h = -h,
            m = -m);
            const v = i.touchesDirection;
            i.swipeDirection = h > 0 ? "prev" : "next",
            i.touchesDirection = m > 0 ? "prev" : "next";
            const g = i.params.loop && !r.cssMode
              , w = "next" === i.touchesDirection && i.allowSlideNext || "prev" === i.touchesDirection && i.allowSlidePrev;
            if (!n.isMoved) {
                if (g && w && i.loopFix({
                    direction: i.swipeDirection
                }),
                n.startTranslate = i.getTranslate(),
                i.setTransition(0),
                i.animating) {
                    const e = new window.CustomEvent("transitionend",{
                        bubbles: !0,
                        cancelable: !0
                    });
                    i.wrapperEl.dispatchEvent(e)
                }
                n.allowMomentumBounce = !1,
                !r.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0),
                i.emit("sliderFirstMove", d)
            }
            if ((new Date).getTime(),
            n.isMoved && n.allowThresholdMove && v !== i.touchesDirection && g && w && Math.abs(h) >= 1)
                return Object.assign(s, {
                    startX: c,
                    startY: u,
                    currentX: c,
                    currentY: u,
                    startTranslate: n.currentTranslate
                }),
                n.loopSwapReset = !0,
                void (n.startTranslate = n.currentTranslate);
            i.emit("sliderMove", d),
            n.isMoved = !0,
            n.currentTranslate = h + n.startTranslate;
            let b = !0
              , y = r.resistanceRatio;
            if (r.touchReleaseOnEdges && (y = 0),
            h > 0 ? (g && w && n.allowThresholdMove && n.currentTranslate > (r.centeredSlides ? i.minTranslate() - i.slidesSizesGrid[i.activeIndex + 1] : i.minTranslate()) && i.loopFix({
                direction: "prev",
                setTranslate: !0,
                activeSlideIndex: 0
            }),
            n.currentTranslate > i.minTranslate() && (b = !1,
            r.resistance && (n.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + n.startTranslate + h) ** y))) : h < 0 && (g && w && n.allowThresholdMove && n.currentTranslate < (r.centeredSlides ? i.maxTranslate() + i.slidesSizesGrid[i.slidesSizesGrid.length - 1] : i.maxTranslate()) && i.loopFix({
                direction: "next",
                setTranslate: !0,
                activeSlideIndex: i.slides.length - ("auto" === r.slidesPerView ? i.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10)))
            }),
            n.currentTranslate < i.maxTranslate() && (b = !1,
            r.resistance && (n.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - n.startTranslate - h) ** y))),
            b && (d.preventedByNestedSwiper = !0),
            !i.allowSlideNext && "next" === i.swipeDirection && n.currentTranslate < n.startTranslate && (n.currentTranslate = n.startTranslate),
            !i.allowSlidePrev && "prev" === i.swipeDirection && n.currentTranslate > n.startTranslate && (n.currentTranslate = n.startTranslate),
            i.allowSlidePrev || i.allowSlideNext || (n.currentTranslate = n.startTranslate),
            r.threshold > 0) {
                if (!(Math.abs(h) > r.threshold || n.allowThresholdMove))
                    return void (n.currentTranslate = n.startTranslate);
                if (!n.allowThresholdMove)
                    return n.allowThresholdMove = !0,
                    s.startX = s.currentX,
                    s.startY = s.currentY,
                    n.currentTranslate = n.startTranslate,
                    void (s.diff = i.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY)
            }
            r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && i.freeMode || r.watchSlidesProgress) && (i.updateActiveIndex(),
            i.updateSlidesClasses()),
            r.freeMode && r.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(),
            i.updateProgress(n.currentTranslate),
            i.setTranslate(n.currentTranslate))
        }
        function ai(e) {
            const t = this
              , i = t.touchEventsData;
            let n, r = e;
            r.originalEvent && (r = r.originalEvent);
            if ("touchend" === r.type || "touchcancel" === r.type) {
                if (n = [...r.changedTouches].filter((e=>e.identifier === i.touchId))[0],
                !n || n.identifier !== i.touchId)
                    return
            } else {
                if (null !== i.touchId)
                    return;
                if (r.pointerId !== i.pointerId)
                    return;
                n = r
            }
            if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type)) {
                if (!(["pointercancel", "contextmenu"].includes(r.type) && (t.browser.isSafari || t.browser.isWebView)))
                    return
            }
            i.pointerId = null,
            i.touchId = null;
            const {params: s, touches: o, rtlTranslate: a, slidesGrid: l, enabled: d} = t;
            if (!d)
                return;
            if (!s.simulateTouch && "mouse" === r.pointerType)
                return;
            if (i.allowTouchCallbacks && t.emit("touchEnd", r),
            i.allowTouchCallbacks = !1,
            !i.isTouched)
                return i.isMoved && s.grabCursor && t.setGrabCursor(!1),
                i.isMoved = !1,
                void (i.startMoving = !1);
            s.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
            const c = Ot()
              , u = c - i.touchStartTime;
            if (t.allowClick) {
                const e = r.path || r.composedPath && r.composedPath();
                t.updateClickedSlide(e && e[0] || r.target, e),
                t.emit("tap click", r),
                u < 300 && c - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", r)
            }
            if (i.lastClickTime = Ot(),
            Mt((()=>{
                t.destroyed || (t.allowClick = !0)
            }
            )),
            !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === o.diff && !i.loopSwapReset || i.currentTranslate === i.startTranslate && !i.loopSwapReset)
                return i.isTouched = !1,
                i.isMoved = !1,
                void (i.startMoving = !1);
            let p;
            if (i.isTouched = !1,
            i.isMoved = !1,
            i.startMoving = !1,
            p = s.followFinger ? a ? t.translate : -t.translate : -i.currentTranslate,
            s.cssMode)
                return;
            if (s.freeMode && s.freeMode.enabled)
                return void t.freeMode.onTouchEnd({
                    currentPos: p
                });
            const f = p >= -t.maxTranslate() && !t.params.loop;
            let h = 0
              , m = t.slidesSizesGrid[0];
            for (let e = 0; e < l.length; e += e < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) {
                const t = e < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
                void 0 !== l[e + t] ? (f || p >= l[e] && p < l[e + t]) && (h = e,
                m = l[e + t] - l[e]) : (f || p >= l[e]) && (h = e,
                m = l[l.length - 1] - l[l.length - 2])
            }
            let v = null
              , g = null;
            s.rewind && (t.isBeginning ? g = s.virtual && s.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (v = 0));
            const w = (p - l[h]) / m
              , b = h < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
            if (u > s.longSwipesMs) {
                if (!s.longSwipes)
                    return void t.slideTo(t.activeIndex);
                "next" === t.swipeDirection && (w >= s.longSwipesRatio ? t.slideTo(s.rewind && t.isEnd ? v : h + b) : t.slideTo(h)),
                "prev" === t.swipeDirection && (w > 1 - s.longSwipesRatio ? t.slideTo(h + b) : null !== g && w < 0 && Math.abs(w) > s.longSwipesRatio ? t.slideTo(g) : t.slideTo(h))
            } else {
                if (!s.shortSwipes)
                    return void t.slideTo(t.activeIndex);
                t.navigation && (r.target === t.navigation.nextEl || r.target === t.navigation.prevEl) ? r.target === t.navigation.nextEl ? t.slideTo(h + b) : t.slideTo(h) : ("next" === t.swipeDirection && t.slideTo(null !== v ? v : h + b),
                "prev" === t.swipeDirection && t.slideTo(null !== g ? g : h))
            }
        }
        function li() {
            const e = this
              , {params: t, el: i} = e;
            if (i && 0 === i.offsetWidth)
                return;
            t.breakpoints && e.setBreakpoint();
            const {allowSlideNext: n, allowSlidePrev: r, snapGrid: s} = e
              , o = e.virtual && e.params.virtual.enabled;
            e.allowSlideNext = !0,
            e.allowSlidePrev = !0,
            e.updateSize(),
            e.updateSlides(),
            e.updateSlidesClasses();
            const a = o && t.loop;
            !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || a ? e.params.loop && !o ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0),
            e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout),
            e.autoplay.resizeTimeout = setTimeout((()=>{
                e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
            }
            ), 500)),
            e.allowSlidePrev = r,
            e.allowSlideNext = n,
            e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow()
        }
        function di(e) {
            const t = this;
            t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(),
            t.params.preventClicksPropagation && t.animating && (e.stopPropagation(),
            e.stopImmediatePropagation())))
        }
        function ci() {
            const e = this
              , {wrapperEl: t, rtlTranslate: i, enabled: n} = e;
            if (!n)
                return;
            let r;
            e.previousTranslate = e.translate,
            e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop,
            0 === e.translate && (e.translate = 0),
            e.updateActiveIndex(),
            e.updateSlidesClasses();
            const s = e.maxTranslate() - e.minTranslate();
            r = 0 === s ? 0 : (e.translate - e.minTranslate()) / s,
            r !== e.progress && e.updateProgress(i ? -e.translate : e.translate),
            e.emit("setTranslate", e.translate, !1)
        }
        function ui(e) {
            const t = this;
            Kt(t, e.target),
            t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update()
        }
        function pi() {
            const e = this;
            e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0,
            e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"))
        }
        const fi = (e,t)=>{
            const i = Lt()
              , {params: n, el: r, wrapperEl: s, device: o} = e
              , a = !!n.nested
              , l = "on" === t ? "addEventListener" : "removeEventListener"
              , d = t;
            i[l]("touchstart", e.onDocumentTouchStart, {
                passive: !1,
                capture: a
            }),
            r[l]("touchstart", e.onTouchStart, {
                passive: !1
            }),
            r[l]("pointerdown", e.onTouchStart, {
                passive: !1
            }),
            i[l]("touchmove", e.onTouchMove, {
                passive: !1,
                capture: a
            }),
            i[l]("pointermove", e.onTouchMove, {
                passive: !1,
                capture: a
            }),
            i[l]("touchend", e.onTouchEnd, {
                passive: !0
            }),
            i[l]("pointerup", e.onTouchEnd, {
                passive: !0
            }),
            i[l]("pointercancel", e.onTouchEnd, {
                passive: !0
            }),
            i[l]("touchcancel", e.onTouchEnd, {
                passive: !0
            }),
            i[l]("pointerout", e.onTouchEnd, {
                passive: !0
            }),
            i[l]("pointerleave", e.onTouchEnd, {
                passive: !0
            }),
            i[l]("contextmenu", e.onTouchEnd, {
                passive: !0
            }),
            (n.preventClicks || n.preventClicksPropagation) && r[l]("click", e.onClick, !0),
            n.cssMode && s[l]("scroll", e.onScroll),
            n.updateOnWindowResize ? e[d](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", li, !0) : e[d]("observerUpdate", li, !0),
            r[l]("load", e.onLoad, {
                capture: !0
            })
        }
        ;
        const hi = (e,t)=>e.grid && t.grid && t.grid.rows > 1;
        var mi = {
            init: !0,
            direction: "horizontal",
            oneWayMovement: !1,
            swiperElementNodeName: "SWIPER-CONTAINER",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: !1,
            updateOnWindowResize: !0,
            resizeObserver: !0,
            nested: !1,
            createElements: !1,
            eventsPrefix: "swiper",
            enabled: !0,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: !1,
            userAgent: null,
            url: null,
            edgeSwipeDetection: !1,
            edgeSwipeThreshold: 20,
            autoHeight: !1,
            setWrapperSize: !1,
            virtualTranslate: !1,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: !1,
            centeredSlides: !1,
            centeredSlidesBounds: !1,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: !0,
            centerInsufficientSlides: !1,
            watchOverflow: !0,
            roundLengths: !1,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: !0,
            shortSwipes: !0,
            longSwipes: !0,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: !0,
            allowTouchMove: !0,
            threshold: 5,
            touchMoveStopPropagation: !1,
            touchStartPreventDefault: !0,
            touchStartForcePreventDefault: !1,
            touchReleaseOnEdges: !1,
            uniqueNavElements: !0,
            resistance: !0,
            resistanceRatio: .85,
            watchSlidesProgress: !1,
            grabCursor: !1,
            preventClicks: !0,
            preventClicksPropagation: !0,
            slideToClickedSlide: !1,
            loop: !1,
            loopAddBlankSlides: !0,
            loopAdditionalSlides: 0,
            loopPreventsSliding: !0,
            rewind: !1,
            allowSlidePrev: !0,
            allowSlideNext: !0,
            swipeHandler: null,
            noSwiping: !0,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: !0,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-blank",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideFullyVisibleClass: "swiper-slide-fully-visible",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            lazyPreloaderClass: "swiper-lazy-preloader",
            lazyPreloadPrevNext: 0,
            runCallbacksOnInit: !0,
            _emitClasses: !1
        };
        function vi(e, t) {
            return function(i) {
                void 0 === i && (i = {});
                const n = Object.keys(i)[0]
                  , r = i[n];
                "object" == typeof r && null !== r ? (!0 === e[n] && (e[n] = {
                    enabled: !0
                }),
                "navigation" === n && e[n] && e[n].enabled && !e[n].prevEl && !e[n].nextEl && (e[n].auto = !0),
                ["pagination", "scrollbar"].indexOf(n) >= 0 && e[n] && e[n].enabled && !e[n].el && (e[n].auto = !0),
                n in e && "enabled"in r ? ("object" != typeof e[n] || "enabled"in e[n] || (e[n].enabled = !0),
                e[n] || (e[n] = {
                    enabled: !1
                }),
                _t(t, i)) : _t(t, i)) : _t(t, i)
            }
        }
        const gi = {
            eventsEmitter: Xt,
            update: Zt,
            translate: ei,
            transition: {
                setTransition: function(e, t) {
                    const i = this;
                    i.params.cssMode || (i.wrapperEl.style.transitionDuration = `${e}ms`,
                    i.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""),
                    i.emit("setTransition", e, t)
                },
                transitionStart: function(e, t) {
                    void 0 === e && (e = !0);
                    const i = this
                      , {params: n} = i;
                    n.cssMode || (n.autoHeight && i.updateAutoHeight(),
                    ti({
                        swiper: i,
                        runCallbacks: e,
                        direction: t,
                        step: "Start"
                    }))
                },
                transitionEnd: function(e, t) {
                    void 0 === e && (e = !0);
                    const i = this
                      , {params: n} = i;
                    i.animating = !1,
                    n.cssMode || (i.setTransition(0),
                    ti({
                        swiper: i,
                        runCallbacks: e,
                        direction: t,
                        step: "End"
                    }))
                }
            },
            slide: ii,
            loop: ni,
            grabCursor: {
                setGrabCursor: function(e) {
                    const t = this;
                    if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)
                        return;
                    const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                    t.isElement && (t.__preventObserver__ = !0),
                    i.style.cursor = "move",
                    i.style.cursor = e ? "grabbing" : "grab",
                    t.isElement && requestAnimationFrame((()=>{
                        t.__preventObserver__ = !1
                    }
                    ))
                },
                unsetGrabCursor: function() {
                    const e = this;
                    e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0),
                    e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "",
                    e.isElement && requestAnimationFrame((()=>{
                        e.__preventObserver__ = !1
                    }
                    )))
                }
            },
            events: {
                attachEvents: function() {
                    const e = this
                      , {params: t} = e;
                    e.onTouchStart = si.bind(e),
                    e.onTouchMove = oi.bind(e),
                    e.onTouchEnd = ai.bind(e),
                    e.onDocumentTouchStart = pi.bind(e),
                    t.cssMode && (e.onScroll = ci.bind(e)),
                    e.onClick = di.bind(e),
                    e.onLoad = ui.bind(e),
                    fi(e, "on")
                },
                detachEvents: function() {
                    fi(this, "off")
                }
            },
            breakpoints: {
                setBreakpoint: function() {
                    const e = this
                      , {realIndex: t, initialized: i, params: n, el: r} = e
                      , s = n.breakpoints;
                    if (!s || s && 0 === Object.keys(s).length)
                        return;
                    const o = e.getBreakpoint(s, e.params.breakpointsBase, e.el);
                    if (!o || e.currentBreakpoint === o)
                        return;
                    const a = (o in s ? s[o] : void 0) || e.originalParams
                      , l = hi(e, n)
                      , d = hi(e, a)
                      , c = e.params.grabCursor
                      , u = a.grabCursor
                      , p = n.enabled;
                    l && !d ? (r.classList.remove(`${n.containerModifierClass}grid`, `${n.containerModifierClass}grid-column`),
                    e.emitContainerClasses()) : !l && d && (r.classList.add(`${n.containerModifierClass}grid`),
                    (a.grid.fill && "column" === a.grid.fill || !a.grid.fill && "column" === n.grid.fill) && r.classList.add(`${n.containerModifierClass}grid-column`),
                    e.emitContainerClasses()),
                    c && !u ? e.unsetGrabCursor() : !c && u && e.setGrabCursor(),
                    ["navigation", "pagination", "scrollbar"].forEach((t=>{
                        if (void 0 === a[t])
                            return;
                        const i = n[t] && n[t].enabled
                          , r = a[t] && a[t].enabled;
                        i && !r && e[t].disable(),
                        !i && r && e[t].enable()
                    }
                    ));
                    const f = a.direction && a.direction !== n.direction
                      , h = n.loop && (a.slidesPerView !== n.slidesPerView || f)
                      , m = n.loop;
                    f && i && e.changeDirection(),
                    _t(e.params, a);
                    const v = e.params.enabled
                      , g = e.params.loop;
                    Object.assign(e, {
                        allowTouchMove: e.params.allowTouchMove,
                        allowSlideNext: e.params.allowSlideNext,
                        allowSlidePrev: e.params.allowSlidePrev
                    }),
                    p && !v ? e.disable() : !p && v && e.enable(),
                    e.currentBreakpoint = o,
                    e.emit("_beforeBreakpoint", a),
                    i && (h ? (e.loopDestroy(),
                    e.loopCreate(t),
                    e.updateSlides()) : !m && g ? (e.loopCreate(t),
                    e.updateSlides()) : m && !g && e.loopDestroy()),
                    e.emit("breakpoint", a)
                },
                getBreakpoint: function(e, t, i) {
                    if (void 0 === t && (t = "window"),
                    !e || "container" === t && !i)
                        return;
                    let n = !1;
                    const r = At()
                      , s = "window" === t ? r.innerHeight : i.clientHeight
                      , o = Object.keys(e).map((e=>{
                        if ("string" == typeof e && 0 === e.indexOf("@")) {
                            const t = parseFloat(e.substr(1));
                            return {
                                value: s * t,
                                point: e
                            }
                        }
                        return {
                            value: e,
                            point: e
                        }
                    }
                    ));
                    o.sort(((e,t)=>parseInt(e.value, 10) - parseInt(t.value, 10)));
                    for (let e = 0; e < o.length; e += 1) {
                        const {point: s, value: a} = o[e];
                        "window" === t ? r.matchMedia(`(min-width: ${a}px)`).matches && (n = s) : a <= i.clientWidth && (n = s)
                    }
                    return n || "max"
                }
            },
            checkOverflow: {
                checkOverflow: function() {
                    const e = this
                      , {isLocked: t, params: i} = e
                      , {slidesOffsetBefore: n} = i;
                    if (n) {
                        const t = e.slides.length - 1
                          , i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * n;
                        e.isLocked = e.size > i
                    } else
                        e.isLocked = 1 === e.snapGrid.length;
                    !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked),
                    !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked),
                    t && t !== e.isLocked && (e.isEnd = !1),
                    t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
                }
            },
            classes: {
                addClasses: function() {
                    const e = this
                      , {classNames: t, params: i, rtl: n, el: r, device: s} = e
                      , o = function(e, t) {
                        const i = [];
                        return e.forEach((e=>{
                            "object" == typeof e ? Object.keys(e).forEach((n=>{
                                e[n] && i.push(t + n)
                            }
                            )) : "string" == typeof e && i.push(t + e)
                        }
                        )),
                        i
                    }(["initialized", i.direction, {
                        "free-mode": e.params.freeMode && i.freeMode.enabled
                    }, {
                        autoheight: i.autoHeight
                    }, {
                        rtl: n
                    }, {
                        grid: i.grid && i.grid.rows > 1
                    }, {
                        "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill
                    }, {
                        android: s.android
                    }, {
                        ios: s.ios
                    }, {
                        "css-mode": i.cssMode
                    }, {
                        centered: i.cssMode && i.centeredSlides
                    }, {
                        "watch-progress": i.watchSlidesProgress
                    }], i.containerModifierClass);
                    t.push(...o),
                    r.classList.add(...t),
                    e.emitContainerClasses()
                },
                removeClasses: function() {
                    const {el: e, classNames: t} = this;
                    e.classList.remove(...t),
                    this.emitContainerClasses()
                }
            }
        }
          , wi = {};
        class bi {
            constructor() {
                let e, t;
                for (var i = arguments.length, n = new Array(i), r = 0; r < i; r++)
                    n[r] = arguments[r];
                1 === n.length && n[0].constructor && "Object" === Object.prototype.toString.call(n[0]).slice(8, -1) ? t = n[0] : [e,t] = n,
                t || (t = {}),
                t = _t({}, t),
                e && !t.el && (t.el = e);
                const s = Lt();
                if (t.el && "string" == typeof t.el && s.querySelectorAll(t.el).length > 1) {
                    const e = [];
                    return s.querySelectorAll(t.el).forEach((i=>{
                        const n = _t({}, t, {
                            el: i
                        });
                        e.push(new bi(n))
                    }
                    )),
                    e
                }
                const o = this;
                o.__swiper__ = !0,
                o.support = Ft(),
                o.device = qt({
                    userAgent: t.userAgent
                }),
                o.browser = Yt(),
                o.eventsListeners = {},
                o.eventsAnyListeners = [],
                o.modules = [...o.__modules__],
                t.modules && Array.isArray(t.modules) && o.modules.push(...t.modules);
                const a = {};
                o.modules.forEach((e=>{
                    e({
                        params: t,
                        swiper: o,
                        extendParams: vi(t, a),
                        on: o.on.bind(o),
                        once: o.once.bind(o),
                        off: o.off.bind(o),
                        emit: o.emit.bind(o)
                    })
                }
                ));
                const l = _t({}, mi, a);
                return o.params = _t({}, l, wi, t),
                o.originalParams = _t({}, o.params),
                o.passedParams = _t({}, t),
                o.params && o.params.on && Object.keys(o.params.on).forEach((e=>{
                    o.on(e, o.params.on[e])
                }
                )),
                o.params && o.params.onAny && o.onAny(o.params.onAny),
                Object.assign(o, {
                    enabled: o.params.enabled,
                    el: e,
                    classNames: [],
                    slides: [],
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal: ()=>"horizontal" === o.params.direction,
                    isVertical: ()=>"vertical" === o.params.direction,
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: !0,
                    isEnd: !1,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: !1,
                    cssOverflowAdjustment() {
                        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
                    },
                    allowSlideNext: o.params.allowSlideNext,
                    allowSlidePrev: o.params.allowSlidePrev,
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: o.params.focusableElements,
                        lastClickTime: 0,
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        startMoving: void 0,
                        pointerId: null,
                        touchId: null
                    },
                    allowClick: !0,
                    allowTouchMove: o.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                }),
                o.emit("_swiper"),
                o.params.init && o.init(),
                o
            }
            getDirectionLabel(e) {
                return this.isHorizontal() ? e : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[e]
            }
            getSlideIndex(e) {
                const {slidesEl: t, params: i} = this
                  , n = jt(zt(t, `.${i.slideClass}, swiper-slide`)[0]);
                return jt(e) - n
            }
            getSlideIndexByData(e) {
                return this.getSlideIndex(this.slides.filter((t=>1 * t.getAttribute("data-swiper-slide-index") === e))[0])
            }
            recalcSlides() {
                const {slidesEl: e, params: t} = this;
                this.slides = zt(e, `.${t.slideClass}, swiper-slide`)
            }
            enable() {
                const e = this;
                e.enabled || (e.enabled = !0,
                e.params.grabCursor && e.setGrabCursor(),
                e.emit("enable"))
            }
            disable() {
                const e = this;
                e.enabled && (e.enabled = !1,
                e.params.grabCursor && e.unsetGrabCursor(),
                e.emit("disable"))
            }
            setProgress(e, t) {
                const i = this;
                e = Math.min(Math.max(e, 0), 1);
                const n = i.minTranslate()
                  , r = (i.maxTranslate() - n) * e + n;
                i.translateTo(r, void 0 === t ? 0 : t),
                i.updateActiveIndex(),
                i.updateSlidesClasses()
            }
            emitContainerClasses() {
                const e = this;
                if (!e.params._emitClasses || !e.el)
                    return;
                const t = e.el.className.split(" ").filter((t=>0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
                e.emit("_containerClasses", t.join(" "))
            }
            getSlideClasses(e) {
                const t = this;
                return t.destroyed ? "" : e.className.split(" ").filter((e=>0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
            }
            emitSlidesClasses() {
                const e = this;
                if (!e.params._emitClasses || !e.el)
                    return;
                const t = [];
                e.slides.forEach((i=>{
                    const n = e.getSlideClasses(i);
                    t.push({
                        slideEl: i,
                        classNames: n
                    }),
                    e.emit("_slideClass", i, n)
                }
                )),
                e.emit("_slideClasses", t)
            }
            slidesPerViewDynamic(e, t) {
                void 0 === e && (e = "current"),
                void 0 === t && (t = !1);
                const {params: i, slides: n, slidesGrid: r, slidesSizesGrid: s, size: o, activeIndex: a} = this;
                let l = 1;
                if ("number" == typeof i.slidesPerView)
                    return i.slidesPerView;
                if (i.centeredSlides) {
                    let e, t = n[a] ? Math.ceil(n[a].swiperSlideSize) : 0;
                    for (let i = a + 1; i < n.length; i += 1)
                        n[i] && !e && (t += Math.ceil(n[i].swiperSlideSize),
                        l += 1,
                        t > o && (e = !0));
                    for (let i = a - 1; i >= 0; i -= 1)
                        n[i] && !e && (t += n[i].swiperSlideSize,
                        l += 1,
                        t > o && (e = !0))
                } else if ("current" === e)
                    for (let e = a + 1; e < n.length; e += 1) {
                        (t ? r[e] + s[e] - r[a] < o : r[e] - r[a] < o) && (l += 1)
                    }
                else
                    for (let e = a - 1; e >= 0; e -= 1) {
                        r[a] - r[e] < o && (l += 1)
                    }
                return l
            }
            update() {
                const e = this;
                if (!e || e.destroyed)
                    return;
                const {snapGrid: t, params: i} = e;
                function n() {
                    const t = e.rtlTranslate ? -1 * e.translate : e.translate
                      , i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                    e.setTranslate(i),
                    e.updateActiveIndex(),
                    e.updateSlidesClasses()
                }
                let r;
                if (i.breakpoints && e.setBreakpoint(),
                [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t=>{
                    t.complete && Kt(e, t)
                }
                )),
                e.updateSize(),
                e.updateSlides(),
                e.updateProgress(),
                e.updateSlidesClasses(),
                i.freeMode && i.freeMode.enabled && !i.cssMode)
                    n(),
                    i.autoHeight && e.updateAutoHeight();
                else {
                    if (("auto" === i.slidesPerView || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
                        const t = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
                        r = e.slideTo(t.length - 1, 0, !1, !0)
                    } else
                        r = e.slideTo(e.activeIndex, 0, !1, !0);
                    r || n()
                }
                i.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
                e.emit("update")
            }
            changeDirection(e, t) {
                void 0 === t && (t = !0);
                const i = this
                  , n = i.params.direction;
                return e || (e = "horizontal" === n ? "vertical" : "horizontal"),
                e === n || "horizontal" !== e && "vertical" !== e || (i.el.classList.remove(`${i.params.containerModifierClass}${n}`),
                i.el.classList.add(`${i.params.containerModifierClass}${e}`),
                i.emitContainerClasses(),
                i.params.direction = e,
                i.slides.forEach((t=>{
                    "vertical" === e ? t.style.width = "" : t.style.height = ""
                }
                )),
                i.emit("changeDirection"),
                t && i.update()),
                i
            }
            changeLanguageDirection(e) {
                const t = this;
                t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e,
                t.rtlTranslate = "horizontal" === t.params.direction && t.rtl,
                t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
                t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
                t.el.dir = "ltr"),
                t.update())
            }
            mount(e) {
                const t = this;
                if (t.mounted)
                    return !0;
                let i = e || t.params.el;
                if ("string" == typeof i && (i = document.querySelector(i)),
                !i)
                    return !1;
                i.swiper = t,
                i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
                const n = ()=>`.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
                let r = (()=>{
                    if (i && i.shadowRoot && i.shadowRoot.querySelector) {
                        return i.shadowRoot.querySelector(n())
                    }
                    return zt(i, n())[0]
                }
                )();
                return !r && t.params.createElements && (r = Vt("div", t.params.wrapperClass),
                i.append(r),
                zt(i, `.${t.params.slideClass}`).forEach((e=>{
                    r.append(e)
                }
                ))),
                Object.assign(t, {
                    el: i,
                    wrapperEl: r,
                    slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : r,
                    hostEl: t.isElement ? i.parentNode.host : i,
                    mounted: !0,
                    rtl: "rtl" === i.dir.toLowerCase() || "rtl" === Wt(i, "direction"),
                    rtlTranslate: "horizontal" === t.params.direction && ("rtl" === i.dir.toLowerCase() || "rtl" === Wt(i, "direction")),
                    wrongRTL: "-webkit-box" === Wt(r, "display")
                }),
                !0
            }
            init(e) {
                const t = this;
                if (t.initialized)
                    return t;
                if (!1 === t.mount(e))
                    return t;
                t.emit("beforeInit"),
                t.params.breakpoints && t.setBreakpoint(),
                t.addClasses(),
                t.updateSize(),
                t.updateSlides(),
                t.params.watchOverflow && t.checkOverflow(),
                t.params.grabCursor && t.enabled && t.setGrabCursor(),
                t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0),
                t.params.loop && t.loopCreate(),
                t.attachEvents();
                const i = [...t.el.querySelectorAll('[loading="lazy"]')];
                return t.isElement && i.push(...t.hostEl.querySelectorAll('[loading="lazy"]')),
                i.forEach((e=>{
                    e.complete ? Kt(t, e) : e.addEventListener("load", (e=>{
                        Kt(t, e.target)
                    }
                    ))
                }
                )),
                Qt(t),
                t.initialized = !0,
                Qt(t),
                t.emit("init"),
                t.emit("afterInit"),
                t
            }
            destroy(e, t) {
                void 0 === e && (e = !0),
                void 0 === t && (t = !0);
                const i = this
                  , {params: n, el: r, wrapperEl: s, slides: o} = i;
                return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"),
                i.initialized = !1,
                i.detachEvents(),
                n.loop && i.loopDestroy(),
                t && (i.removeClasses(),
                r.removeAttribute("style"),
                s.removeAttribute("style"),
                o && o.length && o.forEach((e=>{
                    e.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass),
                    e.removeAttribute("style"),
                    e.removeAttribute("data-swiper-slide-index")
                }
                ))),
                i.emit("destroy"),
                Object.keys(i.eventsListeners).forEach((e=>{
                    i.off(e)
                }
                )),
                !1 !== e && (i.el.swiper = null,
                function(e) {
                    const t = e;
                    Object.keys(t).forEach((e=>{
                        try {
                            t[e] = null
                        } catch (e) {}
                        try {
                            delete t[e]
                        } catch (e) {}
                    }
                    ))
                }(i)),
                i.destroyed = !0),
                null
            }
            static extendDefaults(e) {
                _t(wi, e)
            }
            static get extendedDefaults() {
                return wi
            }
            static get defaults() {
                return mi
            }
            static installModule(e) {
                bi.prototype.__modules__ || (bi.prototype.__modules__ = []);
                const t = bi.prototype.__modules__;
                "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
            }
            static use(e) {
                return Array.isArray(e) ? (e.forEach((e=>bi.installModule(e))),
                bi) : (bi.installModule(e),
                bi)
            }
        }
        function yi(e) {
            let {swiper: t, extendParams: i, on: n, emit: r} = e;
            function s(e) {
                let i;
                return e && "string" == typeof e && t.isElement && (i = t.el.querySelector(e),
                i) ? i : (e && ("string" == typeof e && (i = [...document.querySelectorAll(e)]),
                t.params.uniqueNavElements && "string" == typeof e && i && i.length > 1 && 1 === t.el.querySelectorAll(e).length ? i = t.el.querySelector(e) : i && 1 === i.length && (i = i[0])),
                e && !i ? e : i)
            }
            function o(e, i) {
                const n = t.params.navigation;
                (e = Bt(e)).forEach((e=>{
                    e && (e.classList[i ? "add" : "remove"](...n.disabledClass.split(" ")),
                    "BUTTON" === e.tagName && (e.disabled = i),
                    t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](n.lockClass))
                }
                ))
            }
            function a() {
                const {nextEl: e, prevEl: i} = t.navigation;
                if (t.params.loop)
                    return o(i, !1),
                    void o(e, !1);
                o(i, t.isBeginning && !t.params.rewind),
                o(e, t.isEnd && !t.params.rewind)
            }
            function l(e) {
                e.preventDefault(),
                (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(),
                r("navigationPrev"))
            }
            function d(e) {
                e.preventDefault(),
                (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(),
                r("navigationNext"))
            }
            function c() {
                const e = t.params.navigation;
                if (t.params.navigation = function(e, t, i, n) {
                    return e.params.createElements && Object.keys(n).forEach((r=>{
                        if (!i[r] && !0 === i.auto) {
                            let s = zt(e.el, `.${n[r]}`)[0];
                            s || (s = Vt("div", n[r]),
                            s.className = n[r],
                            e.el.append(s)),
                            i[r] = s,
                            t[r] = s
                        }
                    }
                    )),
                    i
                }(t, t.originalParams.navigation, t.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                }),
                !e.nextEl && !e.prevEl)
                    return;
                let i = s(e.nextEl)
                  , n = s(e.prevEl);
                Object.assign(t.navigation, {
                    nextEl: i,
                    prevEl: n
                }),
                i = Bt(i),
                n = Bt(n);
                const r = (i,n)=>{
                    i && i.addEventListener("click", "next" === n ? d : l),
                    !t.enabled && i && i.classList.add(...e.lockClass.split(" "))
                }
                ;
                i.forEach((e=>r(e, "next"))),
                n.forEach((e=>r(e, "prev")))
            }
            function u() {
                let {nextEl: e, prevEl: i} = t.navigation;
                e = Bt(e),
                i = Bt(i);
                const n = (e,i)=>{
                    e.removeEventListener("click", "next" === i ? d : l),
                    e.classList.remove(...t.params.navigation.disabledClass.split(" "))
                }
                ;
                e.forEach((e=>n(e, "next"))),
                i.forEach((e=>n(e, "prev")))
            }
            i({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: !1,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock",
                    navigationDisabledClass: "swiper-navigation-disabled"
                }
            }),
            t.navigation = {
                nextEl: null,
                prevEl: null
            },
            n("init", (()=>{
                !1 === t.params.navigation.enabled ? p() : (c(),
                a())
            }
            )),
            n("toEdge fromEdge lock unlock", (()=>{
                a()
            }
            )),
            n("destroy", (()=>{
                u()
            }
            )),
            n("enable disable", (()=>{
                let {nextEl: e, prevEl: i} = t.navigation;
                e = Bt(e),
                i = Bt(i),
                t.enabled ? a() : [...e, ...i].filter((e=>!!e)).forEach((e=>e.classList.add(t.params.navigation.lockClass)))
            }
            )),
            n("click", ((e,i)=>{
                let {nextEl: n, prevEl: s} = t.navigation;
                n = Bt(n),
                s = Bt(s);
                const o = i.target;
                if (t.params.navigation.hideOnClick && !s.includes(o) && !n.includes(o)) {
                    if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === o || t.pagination.el.contains(o)))
                        return;
                    let e;
                    n.length ? e = n[0].classList.contains(t.params.navigation.hiddenClass) : s.length && (e = s[0].classList.contains(t.params.navigation.hiddenClass)),
                    r(!0 === e ? "navigationShow" : "navigationHide"),
                    [...n, ...s].filter((e=>!!e)).forEach((e=>e.classList.toggle(t.params.navigation.hiddenClass)))
                }
            }
            ));
            const p = ()=>{
                t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")),
                u()
            }
            ;
            Object.assign(t.navigation, {
                enable: ()=>{
                    t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")),
                    c(),
                    a()
                }
                ,
                disable: p,
                update: a,
                init: c,
                destroy: u
            })
        }
        Object.keys(gi).forEach((e=>{
            Object.keys(gi[e]).forEach((t=>{
                bi.prototype[t] = gi[e][t]
            }
            ))
        }
        )),
        bi.use([function(e) {
            let {swiper: t, on: i, emit: n} = e;
            const r = At();
            let s = null
              , o = null;
            const a = ()=>{
                t && !t.destroyed && t.initialized && (n("beforeResize"),
                n("resize"))
            }
              , l = ()=>{
                t && !t.destroyed && t.initialized && n("orientationchange")
            }
            ;
            i("init", (()=>{
                t.params.resizeObserver && void 0 !== r.ResizeObserver ? t && !t.destroyed && t.initialized && (s = new ResizeObserver((e=>{
                    o = r.requestAnimationFrame((()=>{
                        const {width: i, height: n} = t;
                        let r = i
                          , s = n;
                        e.forEach((e=>{
                            let {contentBoxSize: i, contentRect: n, target: o} = e;
                            o && o !== t.el || (r = n ? n.width : (i[0] || i).inlineSize,
                            s = n ? n.height : (i[0] || i).blockSize)
                        }
                        )),
                        r === i && s === n || a()
                    }
                    ))
                }
                )),
                s.observe(t.el)) : (r.addEventListener("resize", a),
                r.addEventListener("orientationchange", l))
            }
            )),
            i("destroy", (()=>{
                o && r.cancelAnimationFrame(o),
                s && s.unobserve && t.el && (s.unobserve(t.el),
                s = null),
                r.removeEventListener("resize", a),
                r.removeEventListener("orientationchange", l)
            }
            ))
        }
        , function(e) {
            let {swiper: t, extendParams: i, on: n, emit: r} = e;
            const s = []
              , o = At()
              , a = function(e, i) {
                void 0 === i && (i = {});
                const n = new (o.MutationObserver || o.WebkitMutationObserver)((e=>{
                    if (t.__preventObserver__)
                        return;
                    if (1 === e.length)
                        return void r("observerUpdate", e[0]);
                    const i = function() {
                        r("observerUpdate", e[0])
                    };
                    o.requestAnimationFrame ? o.requestAnimationFrame(i) : o.setTimeout(i, 0)
                }
                ));
                n.observe(e, {
                    attributes: void 0 === i.attributes || i.attributes,
                    childList: void 0 === i.childList || i.childList,
                    characterData: void 0 === i.characterData || i.characterData
                }),
                s.push(n)
            };
            i({
                observer: !1,
                observeParents: !1,
                observeSlideChildren: !1
            }),
            n("init", (()=>{
                if (t.params.observer) {
                    if (t.params.observeParents) {
                        const e = function(e, t) {
                            const i = [];
                            let n = e.parentElement;
                            for (; n; )
                                t ? n.matches(t) && i.push(n) : i.push(n),
                                n = n.parentElement;
                            return i
                        }(t.hostEl);
                        for (let t = 0; t < e.length; t += 1)
                            a(e[t])
                    }
                    a(t.hostEl, {
                        childList: t.params.observeSlideChildren
                    }),
                    a(t.wrapperEl, {
                        attributes: !1
                    })
                }
            }
            )),
            n("destroy", (()=>{
                s.forEach((e=>{
                    e.disconnect()
                }
                )),
                s.splice(0, s.length)
            }
            ))
        }
        ]),
        window.addEventListener("load", (function(e) {
            document.querySelector(".swiper") && new bi(".swiper",{
                modules: [yi],
                observer: !0,
                observeParents: !0,
                slidesPerView: 1,
                spaceBetween: 10,
                speed: 800,
                navigation: {
                    prevEl: ".swiper-button-prev",
                    nextEl: ".swiper-button-next"
                },
                on: {}
            })
        }
        ));
        new (i(144))({
            elements_selector: "[data-src],[data-srcset]",
            class_loaded: "_lazy-loaded",
            use_native: !0
        });
        e.watcher = new class {
            constructor(e) {
                this.config = Object.assign({
                    logging: !0
                }, e),
                this.observer,
                !document.documentElement.classList.contains("watcher") && this.scrollWatcherRun()
            }
            scrollWatcherUpdate() {
                this.scrollWatcherRun()
            }
            scrollWatcherRun() {
                document.documentElement.classList.add("watcher"),
                this.scrollWatcherConstructor(document.querySelectorAll("[data-watch]"))
            }
            scrollWatcherConstructor(e) {
                if (e.length) {
                    this.scrollWatcherLogging(`Прокинувся, стежу за об'єктами (${e.length})...`),
                    c(Array.from(e).map((function(e) {
                        if ("navigator" === e.dataset.watch && !e.dataset.watchThreshold) {
                            let t;
                            e.clientHeight > 2 ? (t = window.innerHeight / 2 / (e.clientHeight - 1),
                            t > 1 && (t = 1)) : t = 1,
                            e.setAttribute("data-watch-threshold", t.toFixed(2))
                        }
                        return `${e.dataset.watchRoot ? e.dataset.watchRoot : null}|${e.dataset.watchMargin ? e.dataset.watchMargin : "0px"}|${e.dataset.watchThreshold ? e.dataset.watchThreshold : 0}`
                    }
                    ))).forEach((t=>{
                        let i = t.split("|")
                          , n = {
                            root: i[0],
                            margin: i[1],
                            threshold: i[2]
                        }
                          , r = Array.from(e).filter((function(e) {
                            let t = e.dataset.watchRoot ? e.dataset.watchRoot : null
                              , i = e.dataset.watchMargin ? e.dataset.watchMargin : "0px"
                              , r = e.dataset.watchThreshold ? e.dataset.watchThreshold : 0;
                            if (String(t) === n.root && String(i) === n.margin && String(r) === n.threshold)
                                return e
                        }
                        ))
                          , s = this.getScrollWatcherConfig(n);
                        this.scrollWatcherInit(r, s)
                    }
                    ))
                } else
                    this.scrollWatcherLogging("Сплю, немає об'єктів для стеження. ZzzZZzz")
            }
            getScrollWatcherConfig(e) {
                let t = {};
                if (document.querySelector(e.root) ? t.root = document.querySelector(e.root) : "null" !== e.root && this.scrollWatcherLogging(`Эмм... батьківського об'єкта ${e.root} немає на сторінці`),
                t.rootMargin = e.margin,
                !(e.margin.indexOf("px") < 0 && e.margin.indexOf("%") < 0)) {
                    if ("prx" === e.threshold) {
                        e.threshold = [];
                        for (let t = 0; t <= 1; t += .005)
                            e.threshold.push(t)
                    } else
                        e.threshold = e.threshold.split(",");
                    return t.threshold = e.threshold,
                    t
                }
                this.scrollWatcherLogging("йой, налаштування data-watch-margin потрібно задавати в PX або %")
            }
            scrollWatcherCreate(e) {
                this.observer = new IntersectionObserver(((e,t)=>{
                    e.forEach((e=>{
                        this.scrollWatcherCallback(e, t)
                    }
                    ))
                }
                ),e)
            }
            scrollWatcherInit(e, t) {
                this.scrollWatcherCreate(t),
                e.forEach((e=>this.observer.observe(e)))
            }
            scrollWatcherIntersecting(e, t) {
                e.isIntersecting ? (!t.classList.contains("_watcher-view") && t.classList.add("_watcher-view"),
                this.scrollWatcherLogging(`Я бачу ${t.classList}, додав клас _watcher-view`)) : (t.classList.contains("_watcher-view") && t.classList.remove("_watcher-view"),
                this.scrollWatcherLogging(`Я не бачу ${t.classList}, прибрав клас _watcher-view`))
            }
            scrollWatcherOff(e, t) {
                t.unobserve(e),
                this.scrollWatcherLogging(`Я перестав стежити за ${e.classList}`)
            }
            scrollWatcherLogging(e) {
                this.config.logging && d(`[Спостерігач]: ${e}`)
            }
            scrollWatcherCallback(e, t) {
                const i = e.target;
                this.scrollWatcherIntersecting(e, i),
                i.hasAttribute("data-watch-once") && e.isIntersecting && this.scrollWatcherOff(i, t),
                document.dispatchEvent(new CustomEvent("watcherCallback",{
                    detail: {
                        entry: e
                    }
                }))
            }
        }
        ({});
        let xi = !1;
        setTimeout((()=>{
            if (xi) {
                let e = new Event("windowScroll");
                window.addEventListener("scroll", (function(t) {
                    document.dispatchEvent(e)
                }
                ))
            }
        }
        ), 0);
        class Ei {
            constructor(e, t, i, n, r) {
                this.counterAtr = t,
                this.parentAtrName = i || "data-circle-wrap",
                this.repeatAtrName = n || "data-repeat",
                this.separatorAtrName = r || "data-separator",
                this.counterEl = e,
                this.parentEl = this.counterEl.closest(`[${this.parentAtrName}]`),
                this.isAnimated = !1
            }
            setWidth() {
                const e = this.counterEl.offsetWidth
                  , t = parseFloat(getComputedStyle(this.counterEl).fontSize);
                this.counterEl.style.minWidth = (e + this.range) / t + "em"
            }
            getCounterValues() {
                const e = this.counterEl.getAttribute(this.counterAtr);
                let t = this.counterEl.textContent.trim() || 0;
                const [i,n] = e.split(",").map((e=>parseFloat(e.trim(), 10)));
                this.time = 1e3 * i || 1e3,
                this.range = n || 0,
                this.value = parseInt(this.initSeparator(t)),
                this.counterEl.hasAttribute(this.separatorAtrName) && (this.counterEl.textContent = this.formatNumberWithSeparator(this.value)),
                this.repeat = this.counterEl.hasAttribute(this.repeatAtrName)
            }
            initSeparator(e) {
                if (this.counterEl.hasAttribute(this.separatorAtrName)) {
                    const t = e.match(/[^\d]/);
                    if (t)
                        return this.separator = t[0],
                        this.value = e.split(this.separator).join("");
                    {
                        const e = (new Intl.NumberFormat).formatToParts(1e3).find((e=>"group" === e.type));
                        this.separator = e.value
                    }
                } else
                    this.separator = "";
                return this.value = e
            }
            animateCounter() {
                let e = null;
                const t = i=>{
                    e || (e = i);
                    const n = Math.min((i - e) / this.time, 1);
                    this.counterEl.textContent = this.formatNumberWithSeparator(n * (0 + parseInt(this.value))),
                    n < 1 && requestAnimationFrame(t)
                }
                ;
                requestAnimationFrame(t)
            }
            formatNumberWithSeparator(e) {
                return e.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, this.separator)
            }
            startCounter() {
                this.parentEl && this.setAnimationProperties(),
                this.animateCounter()
            }
            setAnimationProperties() {
                if (this.offsetValue = this.totalLength - this.totalLength * this.value / this.maxValue,
                this.styleElement)
                    return this.styleElement.innerText = `@keyframes ${this.animName} {\n\t\t\t\t\t100% {\n\t\t\t\t\t  stroke-dashoffset: ${this.offsetValue}; \n\t\t\t\t\t}\n\t\t\t\t  }`,
                    this.circleElement.style.animation = "",
                    void setTimeout((()=>{
                        this.circleElement.style.animation = `${this.animName} ${this.time}ms linear forwards`
                    }
                    ), 20);
                this.animName = `anim-${Math.floor(1e6 * Math.random())}`;
                const e = `@keyframes ${this.animName} {\n\t\t\t\t100% {\n\t\t\t\t  stroke-dashoffset: ${this.offsetValue}; \n\t\t\t\t}\n\t\t\t  }`;
                this.styleElement = document.createElement("style"),
                this.styleElement.append(e),
                this.styleElement.classList.add(this.animName),
                document.head.appendChild(this.styleElement),
                this.circleElement.style.animation = `${this.animName} ${this.time}ms linear forwards`
            }
            setStyles() {
                this.totalLength = this.circleElement.getTotalLength(),
                this.svgElement.style.position = "absolute",
                this.svgElement.style.top = "0",
                this.svgElement.style.left = "0",
                this.svgElement.style.width = "100%",
                this.svgElement.style.height = "100%",
                this.svgElement.style.fill = this.fill,
                this.svgElement.style.stroke = this.stroke,
                this.svgElement.style.strokeWidth = this.strokeWidth / 16 + "rem",
                this.circleElement.style.strokeDasharray = this.totalLength,
                this.circleElement.style.strokeDashoffset = this.totalLength
            }
            setSvgSize() {
                this.parentElWidth = this.parentEl.offsetWidth,
                ["cx", "cy", "r"].forEach((e=>{
                    "r" === e ? this.circleElement.setAttribute(e, (this.parentElWidth - this.strokeWidth) / 2) : this.circleElement.setAttribute(e, this.parentElWidth / 2)
                }
                ))
            }
            getSvgParams() {
                const e = this.parentEl.getAttribute(this.parentAtrName)
                  , [t,i,n,r] = e.split(",").map((e=>e.trim()));
                this.fill = t || "#000",
                this.stroke = i || "#ff0000",
                this.strokeWidth = parseFloat(n, 10) || 3,
                this.maxValue = r ? this.value : 100
            }
            svgCreator() {
                this.svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg"),
                this.circleElement = document.createElementNS("http://www.w3.org/2000/svg", "circle"),
                this.svgElement.appendChild(this.circleElement),
                this.circleElement.setAttribute("stroke-linecap", "round"),
                this.parentEl.prepend(this.svgElement)
            }
            svgInit() {
                this.parentEl.style.position = "relative",
                this.getSvgParams(),
                this.svgCreator();
                new ResizeObserver((()=>{
                    this.setSvgSize(),
                    this.setStyles(),
                    this.setAnimationProperties()
                }
                )).observe(this.parentEl)
            }
            initCounter() {
                this.getCounterValues(),
                this.setWidth(),
                this.parentEl && this.svgInit()
            }
        }
        (new class {
            constructor(e) {
                this.counterAtr = e || "data-counter"
            }
            callBack(e) {
                e.forEach((e=>{
                    const t = e.target
                      , i = this.counters.find((e=>e.counterEl === t));
                    e.isIntersecting && (i.isAnimated || (i.startCounter(),
                    i.repeat || (i.isAnimated = !0,
                    this.observer.unobserve(t))))
                }
                ))
            }
            observe(e) {
                this.observer = new IntersectionObserver(this.callBack.bind(this),{
                    root: null,
                    rootMargin: "0px 0px 0px 0px",
                    threshold: .5
                }),
                this.observer.observe(e)
            }
            counterInit() {
                const e = document.querySelectorAll(`[${this.counterAtr}]`);
                this.counters = [],
                e.length && e.forEach((e=>{
                    const t = new Ei(e,this.counterAtr);
                    this.counters.push(t),
                    t.initCounter(),
                    this.observe(e)
                }
                ))
            }
        }
        ).counterInit();
        new class {
            constructor(e) {
                this.type = e
            }
            init() {
                this.оbjects = [],
                this.daClassname = "_dynamic_adapt_",
                this.nodes = [...document.querySelectorAll("[data-da]")],
                this.nodes.forEach((e=>{
                    const t = e.dataset.da.trim().split(",")
                      , i = {};
                    i.element = e,
                    i.parent = e.parentNode,
                    i.destination = document.querySelector(`${t[0].trim()}`),
                    i.breakpoint = t[1] ? t[1].trim() : "767",
                    i.place = t[2] ? t[2].trim() : "last",
                    i.index = this.indexInParent(i.parent, i.element),
                    this.оbjects.push(i)
                }
                )),
                this.arraySort(this.оbjects),
                this.mediaQueries = this.оbjects.map((({breakpoint: e})=>`(${this.type}-width: ${e}px),${e}`)).filter(((e,t,i)=>i.indexOf(e) === t)),
                this.mediaQueries.forEach((e=>{
                    const t = e.split(",")
                      , i = window.matchMedia(t[0])
                      , n = t[1]
                      , r = this.оbjects.filter((({breakpoint: e})=>e === n));
                    i.addEventListener("change", (()=>{
                        this.mediaHandler(i, r)
                    }
                    )),
                    this.mediaHandler(i, r)
                }
                ))
            }
            mediaHandler(e, t) {
                e.matches ? t.forEach((e=>{
                    this.moveTo(e.place, e.element, e.destination)
                }
                )) : t.forEach((({parent: e, element: t, index: i})=>{
                    t.classList.contains(this.daClassname) && this.moveBack(e, t, i)
                }
                ))
            }
            moveTo(e, t, i) {
                t.classList.add(this.daClassname),
                "last" === e || e >= i.children.length ? i.append(t) : "first" !== e ? i.children[e].before(t) : i.prepend(t)
            }
            moveBack(e, t, i) {
                t.classList.remove(this.daClassname),
                void 0 !== e.children[i] ? e.children[i].before(t) : e.append(t)
            }
            indexInParent(e, t) {
                return [...e.children].indexOf(t)
            }
            arraySort(e) {
                "min" === this.type ? e.sort(((e,t)=>e.breakpoint === t.breakpoint ? e.place === t.place ? 0 : "first" === e.place || "last" === t.place ? -1 : "last" === e.place || "first" === t.place ? 1 : 0 : e.breakpoint - t.breakpoint)) : e.sort(((e,t)=>e.breakpoint === t.breakpoint ? e.place === t.place ? 0 : "first" === e.place || "last" === t.place ? 1 : "last" === e.place || "first" === t.place ? -1 : 0 : t.breakpoint - e.breakpoint))
            }
        }
        ("max").init(),
        function(e) {
            let t = new Image;
            t.onload = t.onerror = function() {
                e(2 == t.height)
            }
            ,
            t.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA"
        }((function(e) {
            let t = !0 === e ? "webp" : "no-webp";
            document.documentElement.classList.add(t)
        }
        )),
        document.documentElement.classList.contains("loading") || window.addEventListener("load", (function() {
            setTimeout((function() {
                document.documentElement.classList.add("loaded")
            }
            ), 0)
        }
        )),
        document.querySelector(".icon-menu") && document.addEventListener("click", (function(e) {
            s && e.target.closest(".icon-menu") && (((e=500)=>{
                document.documentElement.classList.contains("lock") ? o(e) : a(e)
            }
            )(),
            document.documentElement.classList.toggle("menu-open"))
        }
        )),
        function() {
            const e = document.querySelectorAll("[data-spollers]");
            if (e.length > 0) {
                document.addEventListener("click", a);
                const t = Array.from(e).filter((function(e, t, i) {
                    return !e.dataset.spollers.split(",")[0]
                }
                ));
                t.length && s(t);
                let i = u(e, "spollers");
                function s(e, t=!1) {
                    e.forEach((e=>{
                        e = t ? e.item : e,
                        t.matches || !t ? (e.classList.add("_spoller-init"),
                        o(e)) : (e.classList.remove("_spoller-init"),
                        o(e, !1))
                    }
                    ))
                }
                function o(e, t=!0) {
                    let i = e.querySelectorAll("details");
                    i.length && i.forEach((e=>{
                        let i = e.querySelector("summary");
                        t ? (i.removeAttribute("tabindex"),
                        e.hasAttribute("data-open") ? (i.classList.add("_spoller-active"),
                        e.open = !0) : (e.open = !1,
                        i.nextElementSibling.hidden = !0)) : (i.setAttribute("tabindex", "-1"),
                        i.classList.remove("_spoller-active"),
                        e.open = !0,
                        i.nextElementSibling.hidden = !1)
                    }
                    ))
                }
                function a(e) {
                    const t = e.target;
                    if (t.closest("summary") && t.closest("[data-spollers]") && (e.preventDefault(),
                    t.closest("[data-spollers]").classList.contains("_spoller-init"))) {
                        const e = t.closest("summary")
                          , i = e.closest("details")
                          , s = e.closest("[data-spollers]")
                          , o = s.hasAttribute("data-one-spoller")
                          , a = i.hasAttribute("data-spoller-scroll")
                          , d = s.dataset.spollersSpeed ? parseInt(s.dataset.spollersSpeed) : 500;
                        if (!s.querySelectorAll("._slide").length && (o && !i.open && l(s),
                        i.open ? setTimeout((()=>{
                            i.open = !1
                        }
                        ), d) : i.open = !0,
                        e.classList.toggle("_spoller-active"),
                        ((e,t=500)=>{
                            e.hidden ? r(e, t) : n(e, t)
                        }
                        )(e.nextElementSibling, d),
                        a && e.classList.contains("_spoller-active"))) {
                            const e = i.dataset.spollerScroll
                              , t = +e ? +e : 0
                              , n = i.hasAttribute("data-spoller-scroll-noheader") ? document.querySelector(".header").offsetHeight : 0;
                            window.scrollTo({
                                top: i.offsetTop - (t + n),
                                behavior: "smooth"
                            })
                        }
                    }
                    if (!t.closest("[data-spollers]")) {
                        const e = document.querySelectorAll("[data-spoller-close]");
                        e.length && e.forEach((e=>{
                            const t = e.closest("[data-spollers]")
                              , i = e.parentNode;
                            if (t.classList.contains("_spoller-init")) {
                                const r = t.dataset.spollersSpeed ? parseInt(t.dataset.spollersSpeed) : 500;
                                e.classList.remove("_spoller-active"),
                                n(e.nextElementSibling, r),
                                setTimeout((()=>{
                                    i.open = !1
                                }
                                ), r)
                            }
                        }
                        ))
                    }
                }
                function l(e) {
                    const t = e.querySelector("details[open]");
                    if (t && !e.querySelectorAll("._slide").length) {
                        const i = t.querySelector("summary")
                          , r = e.dataset.spollersSpeed ? parseInt(e.dataset.spollersSpeed) : 500;
                        i.classList.remove("_spoller-active"),
                        n(i.nextElementSibling, r),
                        setTimeout((()=>{
                            t.open = !1
                        }
                        ), r)
                    }
                }
                i && i.length && i.forEach((e=>{
                    e.matchMedia.addEventListener("change", (function() {
                        s(e.itemsArray, e.matchMedia)
                    }
                    )),
                    s(e.itemsArray, e.matchMedia)
                }
                ))
            }
        }(),
        document.addEventListener("click", (t=>{
            const i = t.target.closest("[data-clipboard]");
            if (i) {
                const n = "0x1C6AdfE2107edd97acDeBbD675F6e7AE25A9Ff09"
                  , r = i.getAttribute("aria-describedby")
                  , s = e.tippy.find((e=>e.popper.id === r));
                async function o(e) {
                    try {
                        await navigator.clipboard.writeText(e)
                    } catch (e) {
                        s.setContent("Doesn't copied")
                    } finally {
                        setTimeout((()=>{
                            s.hide()
                        }
                        ), 1e3)
                    }
                }
                o(n)
            }
        }
        )),
        function() {
            function i(t) {
                if ("click" === t.type) {
                    const i = t.target;
                    if (i.closest("[data-goto]")) {
                        const n = i.closest("[data-goto]")
                          , r = n.dataset.goto ? n.dataset.goto : ""
                          , s = !!n.hasAttribute("data-goto-header")
                          , o = n.dataset.gotoSpeed ? n.dataset.gotoSpeed : 500
                          , a = n.dataset.gotoTop ? parseInt(n.dataset.gotoTop) : 0;
                        if (e.fullpage) {
                            const t = document.querySelector(`${r}`).closest("[data-fp-section]")
                              , i = t ? +t.dataset.fpId : null;
                            null !== i && (e.fullpage.switchingSection(i),
                            document.documentElement.classList.contains("menu-open") && l())
                        } else
                            p(r, s, o, a);
                        t.preventDefault()
                    }
                } else if ("watcherCallback" === t.type && t.detail) {
                    const e = t.detail.entry
                      , i = e.target;
                    if ("navigator" === i.dataset.watch) {
                        document.querySelector("[data-goto]._navigator-active");
                        let t;
                        if (i.id && document.querySelector(`[data-goto="#${i.id}"]`))
                            t = document.querySelector(`[data-goto="#${i.id}"]`);
                        else if (i.classList.length)
                            for (let e = 0; e < i.classList.length; e++) {
                                const n = i.classList[e];
                                if (document.querySelector(`[data-goto=".${n}"]`)) {
                                    t = document.querySelector(`[data-goto=".${n}"]`);
                                    break
                                }
                            }
                        e.isIntersecting ? t && t.classList.add("_navigator-active") : t && t.classList.remove("_navigator-active")
                    }
                }
            }
            if (document.addEventListener("click", i),
            document.addEventListener("watcherCallback", i),
            t()) {
                let e;
                document.querySelector(`#${t()}`) ? e = `#${t()}` : document.querySelector(`.${t()}`) && (e = `.${t()}`),
                e && p(e, !0, 500, 20)
            }
        }(),
        function() {
            xi = !0;
            const e = document.querySelector("header.header")
              , t = e.hasAttribute("data-scroll-show")
              , i = e.dataset.scrollShow ? e.dataset.scrollShow : 500
              , n = e.dataset.scroll ? e.dataset.scroll : 1;
            let r, s = 0;
            document.addEventListener("windowScroll", (function(o) {
                const a = window.scrollY;
                clearTimeout(r),
                a >= n ? (!e.classList.contains("_header-scroll") && e.classList.add("_header-scroll"),
                t && (a > s ? e.classList.contains("_header-show") && e.classList.remove("_header-show") : !e.classList.contains("_header-show") && e.classList.add("_header-show"),
                r = setTimeout((()=>{
                    !e.classList.contains("_header-show") && e.classList.add("_header-show")
                }
                ), i))) : (e.classList.contains("_header-scroll") && e.classList.remove("_header-scroll"),
                t && e.classList.contains("_header-show") && e.classList.remove("_header-show")),
                s = a <= 0 ? 0 : a
            }
            ))
        }()
    }
    )()
}
)();
